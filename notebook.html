<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Ohio State ACM-ICPC Team Notebook</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<CENTER><H1><U>Ohio State ACM-ICPC Team Notebook</U></H1></CENTER>
<H1>Table of Contents</H1>
<H2>Essentials</H2>

<OL START=1>
<LI><A HREF="#file1">C++ header</A></LI>
<LI><A HREF="#file2">C++ flags</A></LI>
<LI><A HREF="#file3">C++ input/output</A></LI>
</OL>
<H2>Data structures</H2>

<OL START=4>
<LI><A HREF="#file4">Unordered Set/Map</A></LI>
<LI><A HREF="#file5">Ordered Set/Map</A></LI>
<LI><A HREF="#file6">Suffix array</A></LI>
<LI><A HREF="#file7">Union-find set</A></LI>
<LI><A HREF="#file8">KD-tree</A></LI>
<LI><A HREF="#file9">Splay tree</A></LI>
<LI><A HREF="#file10">segment tree</A></LI>
<LI><A HREF="#file11">Lazy segment tree</A></LI>
<LI><A HREF="#file12">Lowest common ancestor</A></LI>
</OL>
<H2>Combinatorial optimization</H2>

<OL START=13>
<LI><A HREF="#file13">Sparse max-flow</A></LI>
<LI><A HREF="#file14">Min-cost max-flow</A></LI>
<LI><A HREF="#file15">Push-relabel max-flow</A></LI>
<LI><A HREF="#file16">Min-cost matching</A></LI>
<LI><A HREF="#file17">Max bipartite matching</A></LI>
<LI><A HREF="#file18">Global min-cut</A></LI>
<LI><A HREF="#file19">Graph cut inference</A></LI>
</OL>
<H2>Geometry</H2>

<OL START=20>
<LI><A HREF="#file20">Convex hull</A></LI>
<LI><A HREF="#file21">Miscellaneous geometry</A></LI>
<LI><A HREF="#file22">3D geometry</A></LI>
<LI><A HREF="#file23">Slow Delaunay triangulation</A></LI>
</OL>
<H2>Numerical algorithms</H2>

<OL START=24>
<LI><A HREF="#file24">Number theory (modular, Chinese remainder, linear Diophantine)</A></LI>
<LI><A HREF="#file25">Systems of linear equations, matrix inverse, determinant</A></LI>
<LI><A HREF="#file26">Reduced row echelon form, matrix rank</A></LI>
<LI><A HREF="#file27">Fast Fourier transform</A></LI>
<LI><A HREF="#file28">Simplex algorithm</A></LI>
<LI><A HREF="#file29">Euler's Toitent Function</A></LI>
<LI><A HREF="#file30">Partitions</A></LI>
</OL>
<H2>Graph algorithms</H2>

<OL START=31>
<LI><A HREF="#file31">Bellman-Ford shortest paths with negative edge weights (C++)</A></LI>
<LI><A HREF="#file32">Topological sort (C++)</A></LI>
<LI><A HREF="#file33">Fast Dijkstra's algorithm</A></LI>
<LI><A HREF="#file34">Strongly connected components</A></LI>
<LI><A HREF="#file35">Eulerian path</A></LI>
<LI><A HREF="#file36">Minimum spanning trees</A></LI>
</OL>
<H2>Strings</H2>

<OL START=37>
<LI><A HREF="#file37">Longest increasing subsequence</A></LI>
<LI><A HREF="#file38">Longest common subsequence</A></LI>
<LI><A HREF="#file39">Knuth-Morris-Pratt</A></LI>
<LI><A HREF="#file40">Longest Common Prefix</A></LI>
<LI><A HREF="#file41">Palindromes</A></LI>
</OL>
<H2>Miscellaneous</H2>

<OL START=42>
<LI><A HREF="#file42">Prime numbers</A></LI>
<LI><A HREF="#file43">Binary Search</A></LI>
<LI><A HREF="#file44">Latitude/longitude</A></LI>
<LI><A HREF="#file45">Constraint satisfaction problems</A></LI>
</OL>
<HR>
<A NAME="file1">
<H1>code/cppheader.cc 1/45</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
# <B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">rep</FONT></B>(i, a, b) for(int i = a; i &lt; (b); ++i)
# <B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">trav</FONT></B>(a, x) for(auto&amp; a : x)
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ll;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; pii;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;</PRE>
<HR>
<A NAME="file2">
<H1>code/DebugHeader.txt 2/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
# Add this to the CMakeLists in CLion to crash with bad memory accesses and give better warnings.
# Don't include this comment, comments don't work in CMakeLists.
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Wall -Wextra -Wno-sign-compare -D _GLIBCXX_DEBUG -D _GLIBCXX_DEBUG_PEDANTIC &quot;)
</PRE>
<HR>
<A NAME="file3">
<H1>code/IO.cc 3/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bitset&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

    <I><FONT COLOR="#B22222">// Output a specific number of digits past the decimal point,
</FONT></I>    <I><FONT COLOR="#B22222">// in this case 5    
</FONT></I>    cout.setf(ios::fixed);
    cout &lt;&lt; setprecision(5);
    cout &lt;&lt; 100.0 / 7.0 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; 10.0 &lt;&lt; endl; <I><FONT COLOR="#B22222">// 14.28571 10.00000
</FONT></I>    cout.unsetf(ios::fixed);

    <I><FONT COLOR="#B22222">// Output a '+' before positive values
</FONT></I>    cout.setf(ios::showpos);
    cout &lt;&lt; 100 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; -100 &lt;&lt; endl; <I><FONT COLOR="#B22222">// +100 -100
</FONT></I>    cout.unsetf(ios::showpos);

    <I><FONT COLOR="#B22222">// Output numerical values in hexadecimal. Also works for oct
</FONT></I>    cout &lt;&lt; hex &lt;&lt; 500 &lt;&lt; dec &lt;&lt; endl; <I><FONT COLOR="#B22222">// 1f4 (1*256 + 15*16 + 4*1)
</FONT></I>    <I><FONT COLOR="#B22222">// Output numerical values in binary
</FONT></I>    <B><FONT COLOR="#5F9EA0">std</FONT></B>::bitset&lt;10&gt; bs(500);
    cout &lt;&lt; bs &lt;&lt; endl; <I><FONT COLOR="#B22222">// 0111110100
</FONT></I>
    <I><FONT COLOR="#B22222">// Read until end of file.
</FONT></I>    string line;
    getline(cin, line);
    <B><FONT COLOR="#A020F0">while</FONT></B> (!line.empty()) { <I><FONT COLOR="#B22222">// Input in CP problems always ends with an empty line.
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> intV; string stringV;
        stringstream line_stream(line);
        line_stream &gt;&gt; stringV &gt;&gt; intV; <I><FONT COLOR="#B22222">// Just read like usual from the stream
</FONT></I>        getline(cin, line);
    }
}
</PRE>
<HR>
<A NAME="file4">
<H1>code/UnorderedSetMap.cc 4/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// An example of policy hashtable with a custom object in cpp. It is
</FONT></I><I><FONT COLOR="#B22222">// it is better than the built in unordered_map in that
</FONT></I><I><FONT COLOR="#B22222">// it is ~5 times faster. (https://codeforces.com/blog/entry/60737)
</FONT></I><I><FONT COLOR="#B22222">// No real downsides (normal map is just as annoying with custom objects),
</FONT></I><I><FONT COLOR="#B22222">// but be careful with the hash function, the number of buckets is a power of 2.
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> Coordinate {
    <B><FONT COLOR="#228B22">int</FONT></B> x;
    <B><FONT COLOR="#228B22">int</FONT></B> y;
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;other) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> x == other.x &amp;&amp; y == other.y;
    }
};

ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;stream, <B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;l) {
    <B><FONT COLOR="#A020F0">return</FONT></B> stream &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;{&quot;</FONT></B> &lt;&lt; l.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; l.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;}&quot;</FONT></B>;
}
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ext/pb_ds/assoc_container.hpp&gt;</FONT></B>

<B><FONT COLOR="#228B22">struct</FONT></B> chash {
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> c = uint64_t(7e18) + 13; <I><FONT COLOR="#B22222">// Big prime
</FONT></I>    uint64_t <B><FONT COLOR="#A020F0">operator</FONT></B>()(<B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;l) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> __builtin_bswap64((l.x + l.y) * c);
    }
};

<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> k, <B><FONT COLOR="#228B22">class</FONT></B> v&gt;
using hash_map = __gnu_pbds::gp_hash_table&lt;k, v, chash&gt;;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> k&gt;
using hash_set = __gnu_pbds::gp_hash_table&lt;k, __gnu_pbds::null_type, chash&gt;;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename k, typename v&gt;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">contains</FONT></B>(hash_map&lt;k, v&gt; map, k val) {
    <B><FONT COLOR="#A020F0">return</FONT></B> map.find(val) != map.end();
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <I><FONT COLOR="#B22222">// After importing, writing the template code, overloading ==
</FONT></I>    <I><FONT COLOR="#B22222">// and &lt;&lt; (print) operator like above, you can use the map
</FONT></I>    hash_map&lt;Coordinate, <B><FONT COLOR="#228B22">int</FONT></B>&gt; my_map;
    my_map[{1, 2}] = 17;
    cout &lt;&lt; my_map[{1, 2}] &lt;&lt; endl; <I><FONT COLOR="#B22222">// Prints 17
</FONT></I>    assert(contains(my_map, {1, 2}));
    assert(!contains(my_map, {3, 4}));
    cout &lt;&lt; my_map[{3, 4}] &lt;&lt; endl; <I><FONT COLOR="#B22222">// Prints 0
</FONT></I>    assert(my_map.size() == 2); <I><FONT COLOR="#B22222">// We just set {3, 4} to 0 by accessing it.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> pair : my_map) {
        cout &lt;&lt; pair.first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;=&quot;</FONT></B> &lt;&lt; pair.second &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; <I><FONT COLOR="#B22222">// {3 4}=0 {1 2}=17
</FONT></I>    }

    hash_set&lt;Coordinate&gt; my_set;
    assert(my_set.empty());
    my_set.insert({1, 2});
    assert(contains(my_set, {1, 2}));
    my_set.insert({4, 5});
    <I><FONT COLOR="#B22222">// hash_set does the correct thing, and when you iterate over it you get keys,
</FONT></I>    <I><FONT COLOR="#B22222">// not key-value pairs with a null value.
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> it = my_set.begin(); it != my_set.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;  <I><FONT COLOR="#B22222">// print {4, 5} {1, 2}.
</FONT></I>    }
    <I><FONT COLOR="#B22222">// Standard C Library Equivalent Declarations:
</FONT></I>    <I><FONT COLOR="#B22222">// unordered_map&lt;Coordinate, int, chash&gt; my_map;
</FONT></I>    <I><FONT COLOR="#B22222">// unordered_set&lt;Coordinate, chash&gt; my_set;
</FONT></I>}</PRE>
<HR>
<A NAME="file5">
<H1>code/OrderedSetMap.cc 5/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// An example of using an ordered map with a custom object.
</FONT></I><I><FONT COLOR="#B22222">// Also include code for the gnu policy tree, which gives
</FONT></I><I><FONT COLOR="#B22222">// a easy (~2x slower) segment tree by implementing
</FONT></I><I><FONT COLOR="#B22222">// find_by_order and order_of_key
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> Coordinate {
    <B><FONT COLOR="#228B22">int</FONT></B> x;
    <B><FONT COLOR="#228B22">int</FONT></B> y;
    <I><FONT COLOR="#B22222">// Overloaded for ordered map. If !(c1&lt;c2), !(c2&lt;c1), then
</FONT></I>    <I><FONT COLOR="#B22222">// c1 will be considered equal to c2.
</FONT></I>    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;o) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> x == o.x ? y &lt; o.y : x &lt; o.x;
    }
};

ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;stream, <B><FONT COLOR="#228B22">const</FONT></B> Coordinate &amp;l) {
    <B><FONT COLOR="#A020F0">return</FONT></B> stream &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;{&quot;</FONT></B> &lt;&lt; l.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; l.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;}&quot;</FONT></B>;
}

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ext/pb_ds/assoc_container.hpp&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ext/pb_ds/tree_policy.hpp&gt;</FONT></B>

using namespace __gnu_pbds;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> k, <B><FONT COLOR="#228B22">class</FONT></B> v&gt;
using ordered_map = tree&lt;k, v, less&lt;k&gt;,
        rb_tree_tag, <I><FONT COLOR="#B22222">// Red black tree. Can use splay_tree_tag for a splay tree,
</FONT></I>        <I><FONT COLOR="#B22222">// but split operation for splay is linear time so it may be terrible.
</FONT></I>        tree_order_statistics_node_update <I><FONT COLOR="#B22222">// To get find_by_order and order_of_key methods
</FONT></I>&gt;;
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">class</FONT></B> k&gt; <I><FONT COLOR="#B22222">// Same as ordered map almost
</FONT></I>using ordered_set = tree&lt;k, null_type, less&lt;k&gt;,
        rb_tree_tag, tree_order_statistics_node_update&gt;;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    map&lt;Coordinate, <B><FONT COLOR="#228B22">int</FONT></B>&gt; c_map; <I><FONT COLOR="#B22222">// Standard C Library Ordered Map
</FONT></I>    set&lt;Coordinate&gt; c_set; <I><FONT COLOR="#B22222">// Standard C Library Ordered Set
</FONT></I>    ordered_map&lt;Coordinate, <B><FONT COLOR="#228B22">int</FONT></B>&gt; gnu_map; <I><FONT COLOR="#B22222">// Gnu map declaration
</FONT></I>    ordered_set&lt;Coordinate&gt; gnu_set;<I><FONT COLOR="#B22222">// Gnu set declaration
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 10; i++) {
        gnu_set.insert({0, i * 10});
    }
    cout &lt;&lt; *gnu_set.find({0, 30}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 30}
</FONT></I>    cout &lt;&lt; *gnu_set.lower_bound({0, 53}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 60}
</FONT></I>    cout &lt;&lt; *gnu_set.upper_bound({0, 53}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 60}
</FONT></I>    cout &lt;&lt; *gnu_set.lower_bound({0, 50}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 50}
</FONT></I>    cout &lt;&lt; *gnu_set.upper_bound({0, 50}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0, 60}
</FONT></I>    <I><FONT COLOR="#B22222">// Example of the operations only supported by gnu_set
</FONT></I>    cout &lt;&lt; *gnu_set.find_by_order(2) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0 20}
</FONT></I>    cout &lt;&lt; *gnu_set.find_by_order(4) &lt;&lt; endl; <I><FONT COLOR="#B22222">// {0 40}
</FONT></I>    assert(end(gnu_set) == gnu_set.find_by_order(10));
    cout &lt;&lt; gnu_set.order_of_key({0, -99}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 0
</FONT></I>    cout &lt;&lt; gnu_set.order_of_key({0, 0}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 0
</FONT></I>    cout &lt;&lt; gnu_set.order_of_key({0, 11}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 2
</FONT></I>    cout &lt;&lt; gnu_set.order_of_key({0, 999}) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 10
</FONT></I>}</PRE>
<HR>
<A NAME="file6">
<H1>code/SuffixArray.cc 6/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Suffix array construction in O(L log^2 L) time.  Routine for
</FONT></I><I><FONT COLOR="#B22222">// computing the length of the longest common prefix of any two
</FONT></I><I><FONT COLOR="#B22222">// suffixes in O(log L) time.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:   string s
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:  array suffix[] such that suffix[i] = index (from 0 to L-1)
</FONT></I><I><FONT COLOR="#B22222">//          of substring s[i...L-1] in the list of sorted suffixes.
</FONT></I><I><FONT COLOR="#B22222">//          That is, if we take the inverse of the permutation suffix[],
</FONT></I><I><FONT COLOR="#B22222">//          we get the actual suffix array.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> SuffixArray {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> L;
    string s;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; P;
    vector&lt;pair&lt;pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt;, <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; M;

    SuffixArray(<B><FONT COLOR="#228B22">const</FONT></B> string &amp;s) : L(s.length()), s(s), P(1, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(L, 0)), M(L) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++) P[0][i] = <B><FONT COLOR="#228B22">int</FONT></B>(s[i]);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> skip = 1, level = 1; skip &lt; L; skip *= 2, level++) {
            P.push_back(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(L, 0));
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++)
                M[i] = make_pair(make_pair(P[level - 1][i], i + skip &lt; L ? P[level - 1][i + skip] : -1000), i);
            sort(M.begin(), M.end());
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++)
                P[level][M[i].second] = (i &gt; 0 &amp;&amp; M[i].first == M[i - 1].first) ? P[level][M[i - 1].second] : i;
        }
    }

    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; GetSuffixArray() { <B><FONT COLOR="#A020F0">return</FONT></B> P.back(); }

    <I><FONT COLOR="#B22222">// returns the length of the longest common prefix of s[i...L-1] and s[j...L-1]
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> LongestCommonPrefix(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
        <B><FONT COLOR="#228B22">int</FONT></B> len = 0;
        <B><FONT COLOR="#A020F0">if</FONT></B> (i == j) <B><FONT COLOR="#A020F0">return</FONT></B> L - i;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = P.size() - 1; k &gt;= 0 &amp;&amp; i &lt; L &amp;&amp; j &lt; L; k--) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (P[k][i] == P[k][j]) {
                i += 1 &lt;&lt; k;
                j += 1 &lt;&lt; k;
                len += 1 &lt;&lt; k;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> len;
    }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem 11512: GATTACA.
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">TESTING</FONT>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">TESTING</FONT>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> T;
    cin &gt;&gt; T;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> caseno = 0; caseno &lt; T; caseno++) {
        string s;
        cin &gt;&gt; s;
        SuffixArray array(s);
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = array.GetSuffixArray();
        <B><FONT COLOR="#228B22">int</FONT></B> bestlen = -1, bestpos = -1, bestcount = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; s.length(); i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> len = 0, count = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i + 1; j &lt; s.length(); j++) {
                <B><FONT COLOR="#228B22">int</FONT></B> l = array.LongestCommonPrefix(i, j);
                <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt;= len) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt; len) count = 2; <B><FONT COLOR="#A020F0">else</FONT></B> count++;
                    len = l;
                }
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; bestlen || len == bestlen &amp;&amp; s.substr(bestpos, bestlen) &gt; s.substr(i, len)) {
                bestlen = len;
                bestcount = count;
                bestpos = i;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (bestlen == 0) {
            cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;No repetitions found!&quot;</FONT></B> &lt;&lt; endl;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            cout &lt;&lt; s.substr(bestpos, bestlen) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; bestcount &lt;&lt; endl;
        }
    }
}

#<B><FONT COLOR="#5F9EA0">else
</FONT></B>
<I><FONT COLOR="#B22222">// END CUT
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

  <I><FONT COLOR="#B22222">// bobocel is the 0'th suffix
</FONT></I>  <I><FONT COLOR="#B22222">//  obocel is the 5'th suffix
</FONT></I>  <I><FONT COLOR="#B22222">//   bocel is the 1'st suffix
</FONT></I>  <I><FONT COLOR="#B22222">//    ocel is the 6'th suffix
</FONT></I>  <I><FONT COLOR="#B22222">//     cel is the 2'nd suffix
</FONT></I>  <I><FONT COLOR="#B22222">//      el is the 3'rd suffix
</FONT></I>  <I><FONT COLOR="#B22222">//       l is the 4'th suffix
</FONT></I>  SuffixArray suffix(<B><FONT COLOR="#BC8F8F">&quot;bobocel&quot;</FONT></B>);
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = suffix.GetSuffixArray();
  
  <I><FONT COLOR="#B22222">// Expected output: 0 5 1 6 2 3 4
</FONT></I>  <I><FONT COLOR="#B22222">//                  2
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
  cout &lt;&lt; endl;
  cout &lt;&lt; suffix.LongestCommonPrefix(0, 2) &lt;&lt; endl;
}
<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif
</FONT></B>
<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file7">
<H1>code/UnionFind.cc 7/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> UnionFind {
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; C;
    <I><FONT COLOR="#B22222">// Initialize n disjoint sets with UnionFind(n)
</FONT></I>    UnionFind(<B><FONT COLOR="#228B22">int</FONT></B> n) : C(n) { <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) C[i] = i; }
    <B><FONT COLOR="#228B22">int</FONT></B> find(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> (C[x] == x) ? x : C[x] = find(C[x]); }
    <B><FONT COLOR="#228B22">void</FONT></B> merge(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) { C[find(x)] = find(y); } <I><FONT COLOR="#B22222">// Merge two sets
</FONT></I>};
</PRE>
<HR>
<A NAME="file8">
<H1>code/KDTree.cc 8/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// -----------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// A straightforward, but probably sub-optimal KD-tree implmentation
</FONT></I><I><FONT COLOR="#B22222">// that's probably good enough for most things (current it's a
</FONT></I><I><FONT COLOR="#B22222">// 2D-tree)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  - constructs from n points in O(n lg^2 n) time
</FONT></I><I><FONT COLOR="#B22222">//  - handles nearest-neighbor query in O(lg n) if points are well
</FONT></I><I><FONT COLOR="#B22222">//    distributed
</FONT></I><I><FONT COLOR="#B22222">//  - worst case for nearest-neighbor may be linear in pathological
</FONT></I><I><FONT COLOR="#B22222">//    case
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Sonny Chan, Stanford University, April 2009
</FONT></I><I><FONT COLOR="#B22222">// -----------------------------------------------------------------
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>

using namespace std;

<I><FONT COLOR="#B22222">// number type for coordinates, and its maximum value
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ntype;
<B><FONT COLOR="#228B22">const</FONT></B> ntype sentry = numeric_limits&lt;ntype&gt;::max();

<I><FONT COLOR="#B22222">// point structure for 2D-tree, can be extended to 3D
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> point {
    ntype x, y;
    point(ntype xx = 0, ntype yy = 0) : x(xx), y(yy) {}
};

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a.x == b.x &amp;&amp; a.y == b.y;
}
<I><FONT COLOR="#B22222">// sorts points on x-coordinate
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">on_x</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a.x &lt; b.x;
}
<I><FONT COLOR="#B22222">// sorts points on y-coordinate
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">on_y</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a.y &lt; b.y;
}
<I><FONT COLOR="#B22222">// squared distance between points
</FONT></I>ntype <B><FONT COLOR="#0000FF">pdist2</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    ntype dx = a.x - b.x, dy = a.y - b.y;
    <B><FONT COLOR="#A020F0">return</FONT></B> dx * dx + dy * dy;
}

<I><FONT COLOR="#B22222">// bounding box for a set of points
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> bbox {
    ntype x0, x1, y0, y1;
    bbox() : x0(sentry), x1(-sentry), y0(sentry), y1(-sentry) {}
    <I><FONT COLOR="#B22222">// computes bounding box from a bunch of points
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> compute(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;v) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); ++i) {
            x0 = min(x0, v[i].x);
            x1 = max(x1, v[i].x);
            y0 = min(y0, v[i].y);
            y1 = max(y1, v[i].y);
        }
    }
    <I><FONT COLOR="#B22222">// squared distance between a point and this bbox, 0 if inside
</FONT></I>    ntype distance(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (p.x &lt; x0) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, p.y), p);
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.x &gt; x1) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, p.y), p);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(p.x, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1) <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(p.x, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        }
    }
};

<I><FONT COLOR="#B22222">// stores a single node of the kd-tree, either internal or leaf
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> kdnode {
    <B><FONT COLOR="#228B22">bool</FONT></B> leaf;      <I><FONT COLOR="#B22222">// true if this is a leaf node (has one point)
</FONT></I>    point pt;       <I><FONT COLOR="#B22222">// the single point of this is a leaf
</FONT></I>    bbox bound;     <I><FONT COLOR="#B22222">// bounding box for set of points in children
</FONT></I>
    kdnode *first, *second; <I><FONT COLOR="#B22222">// two children of this kd-node
</FONT></I>
    kdnode() : leaf(false), first(0), second(0) {}
    ~kdnode() {
        <B><FONT COLOR="#A020F0">if</FONT></B> (first) <B><FONT COLOR="#A020F0">delete</FONT></B> first;
        <B><FONT COLOR="#A020F0">if</FONT></B> (second) <B><FONT COLOR="#A020F0">delete</FONT></B> second;
    }
    <I><FONT COLOR="#B22222">// intersect a point with this node (returns squared distance)
</FONT></I>    ntype intersect(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">return</FONT></B> bound.distance(p);
    }
    <I><FONT COLOR="#B22222">// recursively builds a kd-tree from a given cloud of points
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> construct(vector&lt;point&gt; &amp;vp) {
        <I><FONT COLOR="#B22222">// compute bounding box for points at this node
</FONT></I>        bound.compute(vp);

        <I><FONT COLOR="#B22222">// if we're down to one point, then we're a leaf node
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (vp.size() == 1) {
            leaf = true;
            pt = vp[0];
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <I><FONT COLOR="#B22222">// split on x if the bbox is wider than high (not best heuristic...)
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (bound.x1 - bound.x0 &gt;= bound.y1 - bound.y0)
                sort(vp.begin(), vp.end(), on_x);
                <I><FONT COLOR="#B22222">// otherwise split on y-coordinate
</FONT></I>            <B><FONT COLOR="#A020F0">else</FONT></B>
                sort(vp.begin(), vp.end(), on_y);

            <I><FONT COLOR="#B22222">// divide by taking half the array for each child
</FONT></I>            <I><FONT COLOR="#B22222">// (not best performance if many duplicates in the middle)
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> half = vp.size() / 2;
            vector&lt;point&gt; vl(vp.begin(), vp.begin() + half);
            vector&lt;point&gt; vr(vp.begin() + half, vp.end());
            first = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();
            first-&gt;construct(vl);
            second = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();
            second-&gt;construct(vr);
        }
    }
};

<I><FONT COLOR="#B22222">// simple kd-tree class to hold the tree and handle queries
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> kdtree {
    kdnode *root;
    <I><FONT COLOR="#B22222">// constructs a kd-tree from a points (copied here, as it sorts them)
</FONT></I>    kdtree(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;vp) {
        vector&lt;point&gt; v(vp.begin(), vp.end());
        root = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();
        root-&gt;construct(v);
    }
    ~kdtree() { <B><FONT COLOR="#A020F0">delete</FONT></B> root; }
    <I><FONT COLOR="#B22222">// recursive search method returns squared distance to nearest point
</FONT></I>    ntype search(kdnode *node, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;leaf) {
            <I><FONT COLOR="#B22222">// commented special case tells a point not to find itself
</FONT></I><I><FONT COLOR="#B22222">//            if (p == node-&gt;pt) return sentry;
</FONT></I><I><FONT COLOR="#B22222">//            else               
</FONT></I>            <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(p, node-&gt;pt);
        }

        ntype bfirst = node-&gt;first-&gt;intersect(p);
        ntype bsecond = node-&gt;second-&gt;intersect(p);

        <I><FONT COLOR="#B22222">// choose the side with the closest bounding box to search first
</FONT></I>        <I><FONT COLOR="#B22222">// (note that the other side is also searched if needed)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (bfirst &lt; bsecond) {
            ntype best = search(node-&gt;first, p);
            <B><FONT COLOR="#A020F0">if</FONT></B> (bsecond &lt; best)
                best = min(best, search(node-&gt;second, p));
            <B><FONT COLOR="#A020F0">return</FONT></B> best;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            ntype best = search(node-&gt;second, p);
            <B><FONT COLOR="#A020F0">if</FONT></B> (bfirst &lt; best)
                best = min(best, search(node-&gt;first, p));
            <B><FONT COLOR="#A020F0">return</FONT></B> best;
        }
    }
    <I><FONT COLOR="#B22222">// squared distance to the nearest
</FONT></I>    ntype nearest(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">return</FONT></B> search(root, p);
    }
};

<I><FONT COLOR="#B22222">// --------------------------------------------------------------------------
</FONT></I><I><FONT COLOR="#B22222">// some basic test code here
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <I><FONT COLOR="#B22222">// generate some random points for a kd-tree
</FONT></I>    vector&lt;point&gt; vp;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 100000; ++i) {
        vp.push_back(point(rand() % 100000, rand() % 100000));
    }
    kdtree tree(vp);

    <I><FONT COLOR="#B22222">// query some points
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 10; ++i) {
        point q(rand() % 100000, rand() % 100000);
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Closest squared distance to (&quot;</FONT></B> &lt;&lt; q.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B> &lt;&lt; q.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>
             &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; is &quot;</FONT></B> &lt;&lt; tree.nearest(q) &lt;&lt; endl;
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// --------------------------------------------------------------------------
</FONT></I></PRE>
<HR>
<A NAME="file9">
<H1>code/splay.cc 9/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N_MAX = 130010;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> oo = 0x3f3f3f3f;
<B><FONT COLOR="#228B22">struct</FONT></B> Node {
    Node *ch[2], *pre;
    <B><FONT COLOR="#228B22">int</FONT></B> val, size;
    <B><FONT COLOR="#228B22">bool</FONT></B> isTurned;
} nodePool[N_MAX], *null, *root;

Node *<B><FONT COLOR="#0000FF">allocNode</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> val) {
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> freePos = 0;
    Node *x = &amp;nodePool[freePos++];
    x-&gt;val = val, x-&gt;isTurned = false;
    x-&gt;ch[0] = x-&gt;ch[1] = x-&gt;pre = null;
    x-&gt;size = 1;
    <B><FONT COLOR="#A020F0">return</FONT></B> x;
}

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">update</FONT></B>(Node *x) {
    x-&gt;size = x-&gt;ch[0]-&gt;size + x-&gt;ch[1]-&gt;size + 1;
}

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">makeTurned</FONT></B>(Node *x) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (x == null)
        <B><FONT COLOR="#A020F0">return</FONT></B>;
    swap(x-&gt;ch[0], x-&gt;ch[1]);
    x-&gt;isTurned ^= 1;
}

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">pushDown</FONT></B>(Node *x) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (x-&gt;isTurned) {
        makeTurned(x-&gt;ch[0]);
        makeTurned(x-&gt;ch[1]);
        x-&gt;isTurned ^= 1;
    }
}

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">rotate</FONT></B>(Node *x, <B><FONT COLOR="#228B22">int</FONT></B> c) {
    Node *y = x-&gt;pre;
    x-&gt;pre = y-&gt;pre;
    <B><FONT COLOR="#A020F0">if</FONT></B> (y-&gt;pre != null)
        y-&gt;pre-&gt;ch[y == y-&gt;pre-&gt;ch[1]] = x;
    y-&gt;ch[!c] = x-&gt;ch[c];
    <B><FONT COLOR="#A020F0">if</FONT></B> (x-&gt;ch[c] != null)
        x-&gt;ch[c]-&gt;pre = y;
    x-&gt;ch[c] = y, y-&gt;pre = x;
    update(y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (y == root)
        root = x;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">splay</FONT></B>(Node *x, Node *p) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (x-&gt;pre != p) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (x-&gt;pre-&gt;pre == p)
            rotate(x, x == x-&gt;pre-&gt;ch[0]);
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            Node *y = x-&gt;pre, *z = y-&gt;pre;
            <B><FONT COLOR="#A020F0">if</FONT></B> (y == z-&gt;ch[0]) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (x == y-&gt;ch[0])
                    rotate(y, 1), rotate(x, 1);
                <B><FONT COLOR="#A020F0">else</FONT></B>
                    rotate(x, 0), rotate(x, 1);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#A020F0">if</FONT></B> (x == y-&gt;ch[1])
                    rotate(y, 0), rotate(x, 0);
                <B><FONT COLOR="#A020F0">else</FONT></B>
                    rotate(x, 1), rotate(x, 0);
            }
        }
    }
    update(x);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">select</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> k, Node *fa) {
    Node *now = root;
    <B><FONT COLOR="#A020F0">while</FONT></B> (1) {
        pushDown(now);
        <B><FONT COLOR="#228B22">int</FONT></B> tmp = now-&gt;ch[0]-&gt;size + 1;
        <B><FONT COLOR="#A020F0">if</FONT></B> (tmp == k)
            <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tmp &lt; k)
            now = now-&gt;ch[1], k -= tmp;
        <B><FONT COLOR="#A020F0">else</FONT></B>
            now = now-&gt;ch[0];
    }
    splay(now, fa);
}

Node *<B><FONT COLOR="#0000FF">makeTree</FONT></B>(Node *p, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt; r)
        <B><FONT COLOR="#A020F0">return</FONT></B> null;
    <B><FONT COLOR="#228B22">int</FONT></B> mid = (l + r) / 2;
    Node *x = allocNode(mid);
    x-&gt;pre = p;
    x-&gt;ch[0] = makeTree(x, l, mid - 1);
    x-&gt;ch[1] = makeTree(x, mid + 1, r);
    update(x);
    <B><FONT COLOR="#A020F0">return</FONT></B> x;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> n, m;
    null = allocNode(0);
    null-&gt;size = 0;
    root = allocNode(0);
    root-&gt;ch[1] = allocNode(oo);
    root-&gt;ch[1]-&gt;pre = root;
    update(root);

    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;n, &amp;m);
    root-&gt;ch[1]-&gt;ch[0] = makeTree(root-&gt;ch[1], 1, n);
    splay(root-&gt;ch[1]-&gt;ch[0], null);

    <B><FONT COLOR="#A020F0">while</FONT></B> (m--) {
        <B><FONT COLOR="#228B22">int</FONT></B> a, b;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;a, &amp;b);
        a++, b++;
        select(a - 1, null);
        select(b + 1, root);
        makeTurned(root-&gt;ch[1]-&gt;ch[0]);
    }

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) {
        select(i + 1, null);
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, root-&gt;val);
    }
}
</PRE>
<HR>
<A NAME="file10">
<H1>code/SegmentTree.cpp 10/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;
<B><FONT COLOR="#228B22">struct</FONT></B> Tree {
    <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> T;
    <B><FONT COLOR="#228B22">static</FONT></B> constexpr T unit = INT_MIN;
    T f(T a, T b) { <B><FONT COLOR="#A020F0">return</FONT></B> max(a, b); } <I><FONT COLOR="#B22222">// (any associative fn)
</FONT></I>    vector&lt;T&gt; s; <B><FONT COLOR="#228B22">int</FONT></B> n;
    Tree(<B><FONT COLOR="#228B22">int</FONT></B> n = 0, T def = unit) : s(2*n, def), n(n) {}
    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> pos, T val) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (s[pos += n] = val; pos /= 2;)
            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);
    }
    T query(<B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> e) { <I><FONT COLOR="#B22222">// query [b, e)
</FONT></I>        T ra = unit, rb = unit;
        <B><FONT COLOR="#A020F0">for</FONT></B> (b += n, e += n; b &lt; e; b /= 2, e /= 2) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (b % 2) ra = f(ra, s[b++]);
            <B><FONT COLOR="#A020F0">if</FONT></B> (e % 2) rb = f(s[--e], rb);
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> f(ra, rb);
    }
};</PRE>
<HR>
<A NAME="file11">
<H1>code/SegmentTreeLazy.cpp 11/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> inf = 1e9;
<I><FONT COLOR="#B22222">// A lazy segment tree supporting range add, range set, and range get max
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Node {
    Node *l = 0, *r = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> lo, hi, mset = inf, madd = 0, val = -inf;
    Node(<B><FONT COLOR="#228B22">int</FONT></B> lo,<B><FONT COLOR="#228B22">int</FONT></B> hi):lo(lo),hi(hi){} <I><FONT COLOR="#B22222">// Large interval of -inf
</FONT></I>    <I><FONT COLOR="#B22222">// Initialize based on the values in the vector v.
</FONT></I>    <I><FONT COLOR="#B22222">// main will call this with Node(v, 0, v.size())
</FONT></I>    Node(vi&amp; v, <B><FONT COLOR="#228B22">int</FONT></B> lo, <B><FONT COLOR="#228B22">int</FONT></B> hi) : lo(lo), hi(hi) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (lo + 1 &lt; hi) {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = lo + (hi - lo)/2;
            l = <B><FONT COLOR="#A020F0">new</FONT></B> Node(v, lo, mid); r = <B><FONT COLOR="#A020F0">new</FONT></B> Node(v, mid, hi);
            val = max(l-&gt;val, r-&gt;val);
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> val = v[lo];
    }
    <I><FONT COLOR="#B22222">// query [L, R)
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> query(<B><FONT COLOR="#228B22">int</FONT></B> L, <B><FONT COLOR="#228B22">int</FONT></B> R) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (R &lt;= lo || hi &lt;= L) <B><FONT COLOR="#A020F0">return</FONT></B> -inf;
        <B><FONT COLOR="#A020F0">if</FONT></B> (L &lt;= lo &amp;&amp; hi &lt;= R) <B><FONT COLOR="#A020F0">return</FONT></B> val;
        push();
        <B><FONT COLOR="#A020F0">return</FONT></B> max(l-&gt;query(L, R), r-&gt;query(L, R));
    }
    <I><FONT COLOR="#B22222">// set all elements in [L, R) to x
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> set(<B><FONT COLOR="#228B22">int</FONT></B> L, <B><FONT COLOR="#228B22">int</FONT></B> R, <B><FONT COLOR="#228B22">int</FONT></B> x) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (R &lt;= lo || hi &lt;= L) <B><FONT COLOR="#A020F0">return</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (L &lt;= lo &amp;&amp; hi &lt;= R) {
            <I><FONT COLOR="#B22222">// Update the range [lo, hi) to x
</FONT></I>            mset = val = x, madd = 0;
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            push(), l-&gt;set(L, R, x), r-&gt;set(L, R, x);
            val = max(l-&gt;val, r-&gt;val);
        }
    }
    <I><FONT COLOR="#B22222">// add x to all elements in [L, R)
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> add(<B><FONT COLOR="#228B22">int</FONT></B> L, <B><FONT COLOR="#228B22">int</FONT></B> R, <B><FONT COLOR="#228B22">int</FONT></B> x) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (R &lt;= lo || hi &lt;= L) <B><FONT COLOR="#A020F0">return</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (L &lt;= lo &amp;&amp; hi &lt;= R) {
            <I><FONT COLOR="#B22222">// Add x to all elements in the range [lo, hi)
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (mset != inf) mset += x;
            <B><FONT COLOR="#A020F0">else</FONT></B> madd += x;
            val += x;
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            push(), l-&gt;add(L, R, x), r-&gt;add(L, R, x);
            val = max(l-&gt;val, r-&gt;val);
        }
    }
    <I><FONT COLOR="#B22222">// Push the lazily stored values.
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> push() {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!l) {
            <B><FONT COLOR="#228B22">int</FONT></B> mid = lo + (hi - lo)/2;
            l = <B><FONT COLOR="#A020F0">new</FONT></B> Node(lo, mid); r = <B><FONT COLOR="#A020F0">new</FONT></B> Node(mid, hi);
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (mset != inf)
            l-&gt;set(lo,hi,mset), r-&gt;set(lo,hi,mset), mset = inf;
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (madd)
            l-&gt;add(lo,hi,madd), r-&gt;add(lo,hi,madd), madd = 0;
    }
};</PRE>
<HR>
<A NAME="file12">
<H1>code/LCA.cc 12/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> max_nodes, log_max_nodes;
<B><FONT COLOR="#228B22">int</FONT></B> num_nodes, log_num_nodes, root;
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; children[max_nodes];    <I><FONT COLOR="#B22222">// children[i] contains the children of node i
</FONT></I><I><FONT COLOR="#B22222">// A[i][j] is the 2^j-th ancestor of node i, or -1 if that ancestor does not exist
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> A[max_nodes][log_max_nodes + 1];
<B><FONT COLOR="#228B22">int</FONT></B> L[max_nodes];            <I><FONT COLOR="#B22222">// L[i] is the distance between node i and the root
</FONT></I>
<I><FONT COLOR="#B22222">// floor of the binary logarithm of n
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lb</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (n == 0)
        <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    <B><FONT COLOR="#228B22">int</FONT></B> p = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (n &gt;= 1 &lt;&lt; 16) {
        n &gt;&gt;= 16;
        p += 16;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (n &gt;= 1 &lt;&lt; 8) {
        n &gt;&gt;= 8;
        p += 8;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (n &gt;= 1 &lt;&lt; 4) {
        n &gt;&gt;= 4;
        p += 4;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (n &gt;= 1 &lt;&lt; 2) {
        n &gt;&gt;= 2;
        p += 2;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (n &gt;= 1 &lt;&lt; 1) { p += 1; }
    <B><FONT COLOR="#A020F0">return</FONT></B> p;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">DFS</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> l) {
    L[i] = l;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; children[i].size(); j++)
        DFS(children[i][j], l + 1);
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">LCA</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> p, <B><FONT COLOR="#228B22">int</FONT></B> q) {
    <I><FONT COLOR="#B22222">// ensure node p is at least as deep as node q
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (L[p] &lt; L[q])
        swap(p, q);

    <I><FONT COLOR="#B22222">// &quot;binary search&quot; for the ancestor of node p situated on the same level as q
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = log_num_nodes; i &gt;= 0; i--)
        <B><FONT COLOR="#A020F0">if</FONT></B> (L[p] - (1 &lt;&lt; i) &gt;= L[q])
            p = A[p][i];

    <B><FONT COLOR="#A020F0">if</FONT></B> (p == q)
        <B><FONT COLOR="#A020F0">return</FONT></B> p;

    <I><FONT COLOR="#B22222">// &quot;binary search&quot; for the LCA
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = log_num_nodes; i &gt;= 0; i--)
        <B><FONT COLOR="#A020F0">if</FONT></B> (A[p][i] != -1 &amp;&amp; A[p][i] != A[q][i]) {
            p = A[p][i];
            q = A[q][i];
        }

    <B><FONT COLOR="#A020F0">return</FONT></B> A[p][0];
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> *argv[]) {
    <I><FONT COLOR="#B22222">// read num_nodes, the total number of nodes
</FONT></I>    log_num_nodes = lb(num_nodes);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; num_nodes; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> p;
        <I><FONT COLOR="#B22222">// read p, the parent of node i or -1 if node i is the root
</FONT></I>
        A[i][0] = p;
        <B><FONT COLOR="#A020F0">if</FONT></B> (p != -1)
            children[p].push_back(i);
        <B><FONT COLOR="#A020F0">else</FONT></B>
            root = i;
    }

    <I><FONT COLOR="#B22222">// precompute A using dynamic programming
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= log_num_nodes; j++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; num_nodes; i++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (A[i][j - 1] != -1)
                A[i][j] = A[A[i][j - 1]][j - 1];
            <B><FONT COLOR="#A020F0">else</FONT></B>
                A[i][j] = -1;

    <I><FONT COLOR="#B22222">// precompute L
</FONT></I>    DFS(root, 0);

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file13">
<H1>code/Dinic.cc 13/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Adjacency list implementation of Dinic's blocking flow algorithm.
</FONT></I><I><FONT COLOR="#B22222">// This is very fast in practice, and only loses to push-relabel flow.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^2 |E|)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source and sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - maximum flow value
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain actual flow values, look at edges with capacity &gt; 0
</FONT></I><I><FONT COLOR="#B22222">//       (zero capacity edges are residual edges).
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include&lt;cstdio&gt;
</FONT></B>
#<B><FONT COLOR="#5F9EA0">include&lt;vector&gt;
</FONT></B>
#<B><FONT COLOR="#5F9EA0">include&lt;queue&gt;
</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<B><FONT COLOR="#228B22">struct</FONT></B> Edge {
    <B><FONT COLOR="#228B22">int</FONT></B> u, v;
    LL cap, flow;
    Edge() {}
    Edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, LL cap) : u(u), v(v), cap(cap), flow(0) {}
};

<B><FONT COLOR="#228B22">struct</FONT></B> Dinic {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    vector&lt;Edge&gt; E;
    vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; g;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; d, pt;
    Dinic(<B><FONT COLOR="#228B22">int</FONT></B> N) : N(N), E(0), g(N), d(N), pt(N) {}
    <B><FONT COLOR="#228B22">void</FONT></B> AddEdge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, LL cap) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (u != v) {
            E.emplace_back(u, v, cap);
            g[u].emplace_back(E.size() - 1);
            E.emplace_back(v, u, 0);
            g[v].emplace_back(E.size() - 1);
        }
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> BFS(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T) {
        queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q({S});
        fill(d.begin(), d.end(), N + 1);
        d[S] = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (!q.empty()) {
            <B><FONT COLOR="#228B22">int</FONT></B> u = q.front();
            q.pop();
            <B><FONT COLOR="#A020F0">if</FONT></B> (u == T) <B><FONT COLOR="#A020F0">break</FONT></B>;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k: g[u]) {
                Edge &amp;e = E[k];
                <B><FONT COLOR="#A020F0">if</FONT></B> (e.flow &lt; e.cap &amp;&amp; d[e.v] &gt; d[e.u] + 1) {
                    d[e.v] = d[e.u] + 1;
                    q.emplace(e.v);
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> d[T] != N + 1;
    }
    LL DFS(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> T, LL flow = -1) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (u == T || flow == 0) <B><FONT COLOR="#A020F0">return</FONT></B> flow;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> &amp;i = pt[u]; i &lt; g[u].size(); ++i) {
            Edge &amp;e = E[g[u][i]];
            Edge &amp;oe = E[g[u][i] ^ 1];
            <B><FONT COLOR="#A020F0">if</FONT></B> (d[e.v] == d[e.u] + 1) {
                LL amt = e.cap - e.flow;
                <B><FONT COLOR="#A020F0">if</FONT></B> (flow != -1 &amp;&amp; amt &gt; flow) amt = flow;
                <B><FONT COLOR="#A020F0">if</FONT></B> (LL pushed = DFS(e.v, T, amt)) {
                    e.flow += pushed;
                    oe.flow -= pushed;
                    <B><FONT COLOR="#A020F0">return</FONT></B> pushed;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    LL MaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T) {
        LL total = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (BFS(S, T)) {
            fill(pt.begin(), pt.end(), 0);
            <B><FONT COLOR="#A020F0">while</FONT></B> (LL flow = DFS(S, T))
                total += flow;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> total;
    }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves SPOJ problem #4110: Fast Maximum Flow (FASTFLOW)
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, E;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;N, &amp;E);
    Dinic dinic(N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; E; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v;
        LL cap;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d%lld&quot;</FONT></B>, &amp;u, &amp;v, &amp;cap);
        dinic.AddEdge(u - 1, v - 1, cap);
        dinic.AddEdge(v - 1, u - 1, cap);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;%lld\n&quot;</FONT></B>, dinic.MaxFlow(0, N - 1));
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file14">
<H1>code/MinCostMaxFlow.cc 14/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Implementation of min cost max flow algorithm using adjacency
</FONT></I><I><FONT COLOR="#B22222">// matrix (Edmonds and Karp 1972).  This implementation keeps track of
</FONT></I><I><FONT COLOR="#B22222">// forward and reverse edges separately (so you can set cap[i][j] !=
</FONT></I><I><FONT COLOR="#B22222">// cap[j][i]).  For a regular max flow, set all edge costs to 0.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time, O(|V|^2) cost per augmentation
</FONT></I><I><FONT COLOR="#B22222">//     max flow:           O(|V|^3) augmentations
</FONT></I><I><FONT COLOR="#B22222">//     min cost max flow:  O(|V|^4 * MAX_EDGE_COST) augmentations
</FONT></I><I><FONT COLOR="#B22222">//     
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source
</FONT></I><I><FONT COLOR="#B22222">//     - sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (maximum flow value, minimum cost value)
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain the actual flow, look at positive values only.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> L;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;L&gt; VL;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VL&gt; VVL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;
<B><FONT COLOR="#228B22">const</FONT></B> L INF = numeric_limits&lt;L&gt;::max() / 4;

<B><FONT COLOR="#228B22">struct</FONT></B> MinCostMaxFlow {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    VVL cap, flow, cost;
    VI found;
    VL dist, pi, width;
    VPII dad;
    MinCostMaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> N) :
            N(N), cap(N, VL(N)), flow(N, VL(N)), cost(N, VL(N)),
            found(N), dist(N), pi(N), width(N), dad(N) {}
    <B><FONT COLOR="#228B22">void</FONT></B> AddEdge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, L cap, L cost) {
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;cap[from][to] = cap;
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;cost[from][to] = cost;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> Relax(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> k, L cap, L cost, <B><FONT COLOR="#228B22">int</FONT></B> dir) {
        L val = dist[s] + pi[s] - pi[k] + cost;
        <B><FONT COLOR="#A020F0">if</FONT></B> (cap &amp;&amp; val &lt; dist[k]) {
            dist[k] = val;
            dad[k] = make_pair(s, dir);
            width[k] = min(cap, width[s]);
        }
    }
    L Dijkstra(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        fill(found.begin(), found.end(), false);
        fill(dist.begin(), dist.end(), INF);
        fill(width.begin(), width.end(), 0);
        dist[s] = 0;
        width[s] = INF;

        <B><FONT COLOR="#A020F0">while</FONT></B> (s != -1) {
            <B><FONT COLOR="#228B22">int</FONT></B> best = -1;
            found[s] = true;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (found[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                Relax(s, k, cap[s][k] - flow[s][k], cost[s][k], 1);
                Relax(s, k, flow[k][s], -cost[k][s], -1);
                <B><FONT COLOR="#A020F0">if</FONT></B> (best == -1 || dist[k] &lt; dist[best]) best = k;
            }
            s = best;
        }

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++)
            pi[k] = min(pi[k] + dist[k], INF);
        <B><FONT COLOR="#A020F0">return</FONT></B> width[t];
    }
    pair&lt;L, L&gt; GetMaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        L totflow = 0, totcost = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (L amt = Dijkstra(s, t)) {
            totflow += amt;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> x = t; x != s; x = dad[x].first) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (dad[x].second == 1) {
                    flow[dad[x].first][x] += amt;
                    totcost += amt * cost[dad[x].first][x];
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    flow[x][dad[x].first] -= amt;
                    totcost -= amt * cost[x][dad[x].first];
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(totflow, totcost);
    }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem #10594: Data Flow
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, M;

    <B><FONT COLOR="#A020F0">while</FONT></B> (scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;N, &amp;M) == 2) {
        VVL v(M, VL(3));
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++)
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%Ld%Ld%Ld&quot;</FONT></B>, &amp;v[i][0], &amp;v[i][1], &amp;v[i][2]);
        L D, K;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%Ld%Ld&quot;</FONT></B>, &amp;D, &amp;K);

        MinCostMaxFlow mcmf(N + 1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            mcmf.AddEdge(<B><FONT COLOR="#228B22">int</FONT></B>(v[i][0]), <B><FONT COLOR="#228B22">int</FONT></B>(v[i][1]), K, v[i][2]);
            mcmf.AddEdge(<B><FONT COLOR="#228B22">int</FONT></B>(v[i][1]), <B><FONT COLOR="#228B22">int</FONT></B>(v[i][0]), K, v[i][2]);
        }
        mcmf.AddEdge(0, 1, D, 0);

        pair&lt;L, L&gt; res = mcmf.GetMaxFlow(0, N);

        <B><FONT COLOR="#A020F0">if</FONT></B> (res.first == D) {
            printf(<B><FONT COLOR="#BC8F8F">&quot;%Ld\n&quot;</FONT></B>, res.second);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            printf(<B><FONT COLOR="#BC8F8F">&quot;Impossible.\n&quot;</FONT></B>);
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file15">
<H1>code/PushRelabel.cc 15/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Adjacency list implementation of FIFO push relabel maximum flow
</FONT></I><I><FONT COLOR="#B22222">// with the gap relabeling heuristic.  This implementation is
</FONT></I><I><FONT COLOR="#B22222">// significantly faster than straight Ford-Fulkerson.  It solves
</FONT></I><I><FONT COLOR="#B22222">// random problems with 10000 vertices and 1000000 edges in a few
</FONT></I><I><FONT COLOR="#B22222">// seconds, though it is possible to construct test cases that
</FONT></I><I><FONT COLOR="#B22222">// achieve the worst-case.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source
</FONT></I><I><FONT COLOR="#B22222">//     - sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - maximum flow value
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain the actual flow values, look at all edges with
</FONT></I><I><FONT COLOR="#B22222">//       capacity &gt; 0 (zero capacity edges are residual edges).
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<B><FONT COLOR="#228B22">struct</FONT></B> Edge {
  <B><FONT COLOR="#228B22">int</FONT></B> from, to, cap, flow, index;
  Edge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, <B><FONT COLOR="#228B22">int</FONT></B> cap, <B><FONT COLOR="#228B22">int</FONT></B> flow, <B><FONT COLOR="#228B22">int</FONT></B> index) :
    from(from), to(to), cap(cap), flow(flow), index(index) {}
};

<B><FONT COLOR="#228B22">struct</FONT></B> PushRelabel {
  <B><FONT COLOR="#228B22">int</FONT></B> N;
  vector&lt;vector&lt;Edge&gt; &gt; G;
  vector&lt;LL&gt; excess;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dist, active, count;
  queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; Q;

  PushRelabel(<B><FONT COLOR="#228B22">int</FONT></B> N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}

  <B><FONT COLOR="#228B22">void</FONT></B> AddEdge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, <B><FONT COLOR="#228B22">int</FONT></B> cap) {
    G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
    <B><FONT COLOR="#A020F0">if</FONT></B> (from == to) G[from].back().index++;
    G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
  }

  <B><FONT COLOR="#228B22">void</FONT></B> Enqueue(<B><FONT COLOR="#228B22">int</FONT></B> v) { 
    <B><FONT COLOR="#A020F0">if</FONT></B> (!active[v] &amp;&amp; excess[v] &gt; 0) { active[v] = true; Q.push(v); } 
  }

  <B><FONT COLOR="#228B22">void</FONT></B> Push(Edge &amp;e) {
    <B><FONT COLOR="#228B22">int</FONT></B> amt = <B><FONT COLOR="#228B22">int</FONT></B>(min(excess[e.from], LL(e.cap - e.flow)));
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist[e.from] &lt;= dist[e.to] || amt == 0) <B><FONT COLOR="#A020F0">return</FONT></B>;
    e.flow += amt;
    G[e.to][e.index].flow -= amt;
    excess[e.to] += amt;    
    excess[e.from] -= amt;
    Enqueue(e.to);
  }
  
  <B><FONT COLOR="#228B22">void</FONT></B> Gap(<B><FONT COLOR="#228B22">int</FONT></B> k) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = 0; v &lt; N; v++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (dist[v] &lt; k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      count[dist[v]]--;
      dist[v] = max(dist[v], N+1);
      count[dist[v]]++;
      Enqueue(v);
    }
  }

  <B><FONT COLOR="#228B22">void</FONT></B> Relabel(<B><FONT COLOR="#228B22">int</FONT></B> v) {
    count[dist[v]]--;
    dist[v] = 2*N;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; G[v].size(); i++) 
      <B><FONT COLOR="#A020F0">if</FONT></B> (G[v][i].cap - G[v][i].flow &gt; 0)
	dist[v] = min(dist[v], dist[G[v][i].to] + 1);
    count[dist[v]]++;
    Enqueue(v);
  }

  <B><FONT COLOR="#228B22">void</FONT></B> Discharge(<B><FONT COLOR="#228B22">int</FONT></B> v) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; excess[v] &gt; 0 &amp;&amp; i &lt; G[v].size(); i++) Push(G[v][i]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (excess[v] &gt; 0) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (count[dist[v]] == 1) 
	Gap(dist[v]); 
      <B><FONT COLOR="#A020F0">else</FONT></B>
	Relabel(v);
    }
  }

  LL GetMaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
    count[0] = N-1;
    count[N] = 1;
    dist[s] = N;
    active[s] = active[t] = true;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; G[s].size(); i++) {
      excess[s] += G[s][i].cap;
      Push(G[s][i]);
    }
    
    <B><FONT COLOR="#A020F0">while</FONT></B> (!Q.empty()) {
      <B><FONT COLOR="#228B22">int</FONT></B> v = Q.front();
      Q.pop();
      active[v] = false;
      Discharge(v);
    }
    
    LL totflow = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; G[s].size(); i++) totflow += G[s][i].flow;
    <B><FONT COLOR="#A020F0">return</FONT></B> totflow;
  }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves SPOJ problem #4110: Fast Maximum Flow (FASTFLOW)
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">int</FONT></B> n, m;
  scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;n, &amp;m);

  PushRelabel pr(n);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) { 
   <B><FONT COLOR="#228B22">int</FONT></B> a, b, c;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d%d&quot;</FONT></B>, &amp;a, &amp;b, &amp;c);
    <B><FONT COLOR="#A020F0">if</FONT></B> (a == b) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    pr.AddEdge(a-1, b-1, c);
    pr.AddEdge(b-1, a-1, c);
  }
  printf(<B><FONT COLOR="#BC8F8F">&quot;%Ld\n&quot;</FONT></B>, pr.GetMaxFlow(0, n-1));
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file16">
<H1>code/MinCostMatching.cc 16/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file15">prev</A>][<A HREF="#file17">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////
</FONT></I><I><FONT COLOR="#B22222">// Min cost bipartite matching via shortest augmenting paths
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// This is an O(n^3) implementation of a shortest augmenting path
</FONT></I><I><FONT COLOR="#B22222">// algorithm for finding min cost perfect matchings in dense
</FONT></I><I><FONT COLOR="#B22222">// graphs.  In practice, it solves 1000x1000 problems in around 1
</FONT></I><I><FONT COLOR="#B22222">// second.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   cost[i][j] = cost for pairing left node i with right node j
</FONT></I><I><FONT COLOR="#B22222">//   Lmate[i] = index of right node that left node i pairs with
</FONT></I><I><FONT COLOR="#B22222">//   Rmate[j] = index of left node that right node j pairs with
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// The values in cost[i][j] may be positive or negative.  To perform
</FONT></I><I><FONT COLOR="#B22222">// maximization, simply negate the cost[][] matrix.
</FONT></I><I><FONT COLOR="#B22222">//////////////////////////////////////////////////////////////////////
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; VD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VD&gt; VVD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">MinCostMatching</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVD &amp;cost, VI &amp;Lmate, VI &amp;Rmate) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = <B><FONT COLOR="#228B22">int</FONT></B>(cost.size());

    <I><FONT COLOR="#B22222">// construct dual feasible solution
</FONT></I>    VD u(n);
    VD v(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        u[i] = cost[i][0];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; n; j++) u[i] = min(u[i], cost[i][j]);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) {
        v[j] = cost[0][j] - u[0];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
    }

    <I><FONT COLOR="#B22222">// construct primal solution satisfying complementary slackness
</FONT></I>    Lmate = VI(n, -1);
    Rmate = VI(n, -1);
    <B><FONT COLOR="#228B22">int</FONT></B> mated = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (Rmate[j] != -1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(cost[i][j] - u[i] - v[j]) &lt; 1e-10) {
                Lmate[i] = j;
                Rmate[j] = i;
                mated++;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
    }

    VD dist(n);
    VI dad(n);
    VI seen(n);

    <I><FONT COLOR="#B22222">// repeat until primal solution is feasible
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B> (mated &lt; n) {

        <I><FONT COLOR="#B22222">// find an unmatched left node
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> s = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (Lmate[s] != -1) s++;

        <I><FONT COLOR="#B22222">// initialize Dijkstra
</FONT></I>        fill(dad.begin(), dad.end(), -1);
        fill(seen.begin(), seen.end(), 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++)
            dist[k] = cost[s][k] - u[s] - v[k];

        <B><FONT COLOR="#228B22">int</FONT></B> j = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (true) {

            <I><FONT COLOR="#B22222">// find closest
</FONT></I>            j = -1;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                <B><FONT COLOR="#A020F0">if</FONT></B> (j == -1 || dist[k] &lt; dist[j]) j = k;
            }
            seen[j] = 1;

            <I><FONT COLOR="#B22222">// termination condition
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (Rmate[j] == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;

            <I><FONT COLOR="#B22222">// relax neighbors
</FONT></I>            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = Rmate[j];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> new_dist = dist[j] + cost[i][k] - u[i] - v[k];
                <B><FONT COLOR="#A020F0">if</FONT></B> (dist[k] &gt; new_dist) {
                    dist[k] = new_dist;
                    dad[k] = j;
                }
            }
        }

        <I><FONT COLOR="#B22222">// update dual variables
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (k == j || !seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = Rmate[k];
            v[k] += dist[k] - dist[j];
            u[i] -= dist[k] - dist[j];
        }
        u[s] += dist[j];

        <I><FONT COLOR="#B22222">// augment along path
</FONT></I>        <B><FONT COLOR="#A020F0">while</FONT></B> (dad[j] &gt;= 0) {
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> d = dad[j];
            Rmate[j] = Rmate[d];
            Lmate[Rmate[j]] = j;
            j = d;
        }
        Rmate[j] = s;
        Lmate[s] = j;

        mated++;
    }

    <B><FONT COLOR="#228B22">double</FONT></B> value = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
        value += cost[i][Lmate[i]];

    <B><FONT COLOR="#A020F0">return</FONT></B> value;
}
</PRE>
<HR>
<A NAME="file17">
<H1>code/MaxBipartiteMatching.cc 17/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file16">prev</A>][<A HREF="#file18">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This code performs maximum bipartite matching.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|E| |V|) -- often much faster in practice
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT: w[i][j] = edge between row node i and column node j
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT: mr[i] = assignment for row node i, -1 if unassigned
</FONT></I><I><FONT COLOR="#B22222">//           mc[j] = assignment for column node j, -1 if unassigned
</FONT></I><I><FONT COLOR="#B22222">//           function returns number of matches made
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">FindMatch</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;w, VI &amp;mr, VI &amp;mc, VI &amp;seen) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; w[i].size(); j++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (w[i][j] &amp;&amp; !seen[j]) {
            seen[j] = true;
            <B><FONT COLOR="#A020F0">if</FONT></B> (mc[j] &lt; 0 || FindMatch(mc[j], w, mr, mc, seen)) {
                mr[i] = j;
                mc[j] = i;
                <B><FONT COLOR="#A020F0">return</FONT></B> true;
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">BipartiteMatching</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;w, VI &amp;mr, VI &amp;mc) {
    mr = VI(w.size(), -1);
    mc = VI(w[0].size(), -1);

    <B><FONT COLOR="#228B22">int</FONT></B> ct = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; w.size(); i++) {
        VI seen(w[0].size());
        <B><FONT COLOR="#A020F0">if</FONT></B> (FindMatch(i, w, mr, mc, seen)) ct++;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ct;
}
</PRE>
<HR>
<A NAME="file18">
<H1>code/MinCut.cc 18/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file17">prev</A>][<A HREF="#file19">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Adjacency matrix implementation of Stoer-Wagner min cut algorithm.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (min cut value, nodes in half of min cut)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 1000000000;
pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, VI&gt; GetMinCut(VVI &amp;weights) {
    <B><FONT COLOR="#228B22">int</FONT></B> N = weights.size();
    VI used(N), cut, best_cut;
    <B><FONT COLOR="#228B22">int</FONT></B> best_weight = -1;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> phase = N - 1; phase &gt;= 0; phase--) {
        VI w = weights[0];
        VI added = used;
        <B><FONT COLOR="#228B22">int</FONT></B> prev, last = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; phase; i++) {
            prev = last;
            last = -1;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; N; j++)
                <B><FONT COLOR="#A020F0">if</FONT></B> (!added[j] &amp;&amp; (last == -1 || w[j] &gt; w[last])) last = j;
            <B><FONT COLOR="#A020F0">if</FONT></B> (i == phase - 1) {
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[prev][j] += weights[last][j];
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[j][prev] = weights[prev][j];
                used[last] = true;
                cut.push_back(last);
                <B><FONT COLOR="#A020F0">if</FONT></B> (best_weight == -1 || w[last] &lt; best_weight) {
                    best_cut = cut;
                    best_weight = w[last];
                }
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
                    w[j] += weights[last][j];
                added[last] = true;
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(best_weight, best_cut);
}
<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem #10989: Bomb, Divide and Conquer
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    cin &gt;&gt; N;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> n, m;
        cin &gt;&gt; n &gt;&gt; m;
        VVI weights(n, VI(n));
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) {
            <B><FONT COLOR="#228B22">int</FONT></B> a, b, c;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            weights[a - 1][b - 1] = weights[b - 1][a - 1] = c;
        }
        pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, VI&gt; res = GetMinCut(weights);
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Case #&quot;</FONT></B> &lt;&lt; i + 1 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; res.first &lt;&lt; endl;
    }
}
<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file19">
<H1>code/GraphCutInference.cc 19/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file18">prev</A>][<A HREF="#file20">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Special-purpose {0,1} combinatorial optimization solver for
</FONT></I><I><FONT COLOR="#B22222">// problems of the following by a reduction to graph cuts:
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//        minimize         sum_i  psi_i(x[i]) 
</FONT></I><I><FONT COLOR="#B22222">//  x[1]...x[n] in {0,1}      + sum_{i &lt; j}  phi_{ij}(x[i], x[j])
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// where
</FONT></I><I><FONT COLOR="#B22222">//      psi_i : {0, 1} --&gt; R
</FONT></I><I><FONT COLOR="#B22222">//   phi_{ij} : {0, 1} x {0, 1} --&gt; R
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// such that
</FONT></I><I><FONT COLOR="#B22222">//   phi_{ij}(0,0) + phi_{ij}(1,1) &lt;= phi_{ij}(0,1) + phi_{ij}(1,0)  (*)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// This can also be used to solve maximization problems where the
</FONT></I><I><FONT COLOR="#B22222">// direction of the inequality in (*) is reversed.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: phi -- a matrix such that phi[i][j][u][v] = phi_{ij}(u, v)
</FONT></I><I><FONT COLOR="#B22222">//        psi -- a matrix such that psi[i][u] = psi_i(u)
</FONT></I><I><FONT COLOR="#B22222">//        x -- a vector where the optimal solution will be stored
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT: value of the optimal solution
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// To use this code, create a GraphCutInference object, and call the
</FONT></I><I><FONT COLOR="#B22222">// DoInference() method.  To perform maximization instead of minimization,
</FONT></I><I><FONT COLOR="#B22222">// ensure that #define MAXIMIZATION is enabled.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VVI&gt; VVVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VVVI&gt; VVVVI;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 1000000000;

<I><FONT COLOR="#B22222">// comment out following line for minimization
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXIMIZATION</FONT>

<B><FONT COLOR="#228B22">struct</FONT></B> GraphCutInference {
    <B><FONT COLOR="#228B22">int</FONT></B> N;
    VVI cap, flow;
    VI reached;
    <B><FONT COLOR="#228B22">int</FONT></B> Augment(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t, <B><FONT COLOR="#228B22">int</FONT></B> a) {
        reached[s] = 1;
        <B><FONT COLOR="#A020F0">if</FONT></B> (s == t) <B><FONT COLOR="#A020F0">return</FONT></B> a;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (reached[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> aa = min(a, cap[s][k] - flow[s][k])) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> b = Augment(k, t, aa)) {
                    flow[s][k] += b;
                    flow[k][s] -= b;
                    <B><FONT COLOR="#A020F0">return</FONT></B> b;
                }
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    <B><FONT COLOR="#228B22">int</FONT></B> GetMaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
        N = cap.size();
        flow = VVI(N, VI(N));
        reached = VI(N);

        <B><FONT COLOR="#228B22">int</FONT></B> totflow = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> amt = Augment(s, t, INF)) {
            totflow += amt;
            fill(reached.begin(), reached.end(), 0);
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> totflow;
    }
    <B><FONT COLOR="#228B22">int</FONT></B> DoInference(<B><FONT COLOR="#228B22">const</FONT></B> VVVVI &amp;phi, <B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;psi, VI &amp;x) {
        <B><FONT COLOR="#228B22">int</FONT></B> M = phi.size();
        cap = VVI(M + 2, VI(M + 2));
        VI b(M);
        <B><FONT COLOR="#228B22">int</FONT></B> c = 0;

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            b[i] += psi[i][1] - psi[i][0];
            c += psi[i][0];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; i; j++)
                b[i] += phi[i][j][1][1] - phi[i][j][0][1];
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i + 1; j &lt; M; j++) {
                cap[i][j] = phi[i][j][0][1] + phi[i][j][1][0] - phi[i][j][0][0] - phi[i][j][1][1];
                b[i] += phi[i][j][1][0] - phi[i][j][0][0];
                c += phi[i][j][0][0];
            }
        }

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">MAXIMIZATION</FONT>
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i + 1; j &lt; M; j++)
                cap[i][j] *= -1;
            b[i] *= -1;
        }
        c *= -1;
#<B><FONT COLOR="#5F9EA0">endif
</FONT></B>

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (b[i] &gt;= 0) {
                cap[M][i] = b[i];
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                cap[i][M + 1] = -b[i];
                c += b[i];
            }
        }

        <B><FONT COLOR="#228B22">int</FONT></B> score = GetMaxFlow(M, M + 1);
        fill(reached.begin(), reached.end(), 0);
        Augment(M, M + 1, INF);
        x = VI(M);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) x[i] = reached[i] ? 0 : 1;
        score += c;
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">MAXIMIZATION</FONT>
        score *= -1;
#<B><FONT COLOR="#5F9EA0">endif
</FONT></B>

        <B><FONT COLOR="#A020F0">return</FONT></B> score;
    }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

    <I><FONT COLOR="#B22222">// solver for &quot;Cat vs. Dog&quot; from NWERC 2008
</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> numcases;
    cin &gt;&gt; numcases;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> caseno = 0; caseno &lt; numcases; caseno++) {
        <B><FONT COLOR="#228B22">int</FONT></B> c, d, v;
        cin &gt;&gt; c &gt;&gt; d &gt;&gt; v;

        VVVVI phi(c + d, VVVI(c + d, VVI(2, VI(2))));
        VVI psi(c + d, VI(2));
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v; i++) {
            <B><FONT COLOR="#228B22">char</FONT></B> p, q;
            <B><FONT COLOR="#228B22">int</FONT></B> u, v;
            cin &gt;&gt; p &gt;&gt; u &gt;&gt; q &gt;&gt; v;
            u--;
            v--;
            <B><FONT COLOR="#A020F0">if</FONT></B> (p == <B><FONT COLOR="#BC8F8F">'C'</FONT></B>) {
                phi[u][c + v][0][0]++;
                phi[c + v][u][0][0]++;
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                phi[v][c + u][1][1]++;
                phi[c + u][v][1][1]++;
            }
        }
        GraphCutInference graph;
        VI x;
        cout &lt;&lt; graph.DoInference(phi, psi, x) &lt;&lt; endl;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file20">
<H1>code/ConvexHull.cc 20/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file19">prev</A>][<A HREF="#file21">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Compute the 2D convex hull of a set of points using the monotone chain
</FONT></I><I><FONT COLOR="#B22222">// algorithm.  Eliminate redundant points from the hull if REMOVE_REDUNDANT is 
</FONT></I><I><FONT COLOR="#B22222">// #defined.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n log n)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   a vector of input points, unordered.
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  a vector of points in the convex hull, counterclockwise, starting
</FONT></I><I><FONT COLOR="#B22222">//            with bottommost/leftmost point
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;map&gt;</FONT></B>
<I><FONT COLOR="#B22222">// END CUT
</FONT></I>
using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">const</FONT></B> T EPS = 1e-7;

<B><FONT COLOR="#228B22">struct</FONT></B> PT {
    T x, y;
    PT() {}
    PT(T x, T y) : x(x), y(y) {}
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(y, x) &lt; make_pair(rhs.y, rhs.x); }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;rhs) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(y, x) == make_pair(rhs.y, rhs.x); }
};

T cross(PT p, PT q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.x * q.y - p.y * q.x; }
T area2(PT a, PT b, PT c) { <B><FONT COLOR="#A020F0">return</FONT></B> cross(a, b) + cross(b, c) + cross(c, a); }

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">between</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> PT &amp;b, <B><FONT COLOR="#228B22">const</FONT></B> PT &amp;c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> (fabs(area2(a, b, c)) &lt; EPS &amp;&amp; (a.x - b.x) * (c.x - b.x) &lt;= 0 &amp;&amp; (a.y - b.y) * (c.y - b.y) &lt;= 0);
}
#<B><FONT COLOR="#5F9EA0">endif
</FONT></B>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">ConvexHull</FONT></B>(vector&lt;PT&gt; &amp;pts) {
    sort(pts.begin(), pts.end());
    pts.erase(unique(pts.begin(), pts.end()), pts.end());
    vector&lt;PT&gt; up, dn;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; pts.size(); i++) {
        <B><FONT COLOR="#A020F0">while</FONT></B> (up.size() &gt; 1 &amp;&amp; area2(up[up.size() - 2], up.back(), pts[i]) &gt;= 0) up.pop_back();
        <B><FONT COLOR="#A020F0">while</FONT></B> (dn.size() &gt; 1 &amp;&amp; area2(dn[dn.size() - 2], dn.back(), pts[i]) &lt;= 0) dn.pop_back();
        up.push_back(pts[i]);
        dn.push_back(pts[i]);
    }
    pts = dn;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = (<B><FONT COLOR="#228B22">int</FONT></B>) up.size() - 2; i &gt;= 1; i--) pts.push_back(up[i]);

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">REMOVE_REDUNDANT</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> (pts.size() &lt;= 2) <B><FONT COLOR="#A020F0">return</FONT></B>;
    dn.clear();
    dn.push_back(pts[0]);
    dn.push_back(pts[1]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt; pts.size(); i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (between(dn[dn.size() - 2], dn[dn.size() - 1], pts[i])) dn.pop_back();
        dn.push_back(pts[i]);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (dn.size() &gt;= 3 &amp;&amp; between(dn.back(), dn[0], dn[1])) {
        dn[0] = dn.back();
        dn.pop_back();
    }
    pts = dn;
#<B><FONT COLOR="#5F9EA0">endif
</FONT></B>
}

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves SPOJ problem #26: Build the Fence (BSHEEP)
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> t;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;t);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> caseno = 0; caseno &lt; t; caseno++) {
        <B><FONT COLOR="#228B22">int</FONT></B> n;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;n);
        vector&lt;PT&gt; v(n);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) scanf(<B><FONT COLOR="#BC8F8F">&quot;%lf%lf&quot;</FONT></B>, &amp;v[i].x, &amp;v[i].y);
        vector&lt;PT&gt; h(v);
        map&lt;PT, <B><FONT COLOR="#228B22">int</FONT></B>&gt; index;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = n - 1; i &gt;= 0; i--) index[v[i]] = i + 1;
        ConvexHull(h);

        <B><FONT COLOR="#228B22">double</FONT></B> len = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; h.size(); i++) {
            <B><FONT COLOR="#228B22">double</FONT></B> dx = h[i].x - h[(i + 1) % h.size()].x;
            <B><FONT COLOR="#228B22">double</FONT></B> dy = h[i].y - h[(i + 1) % h.size()].y;
            len += sqrt(dx * dx + dy * dy);
        }

        <B><FONT COLOR="#A020F0">if</FONT></B> (caseno &gt; 0) printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
        printf(<B><FONT COLOR="#BC8F8F">&quot;%.2f\n&quot;</FONT></B>, len);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; h.size(); i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; 0) printf(<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>);
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, index[h[i]]);
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    }
}

<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file21">
<H1>code/Geometry.cc 21/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file20">prev</A>][<A HREF="#file22">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// C++ routines for computational geometry.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cassert&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">double</FONT></B> INF = 1e100;
<B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-12;

<B><FONT COLOR="#228B22">struct</FONT></B> PT {
    <B><FONT COLOR="#228B22">double</FONT></B> x, y;
    PT() {}
    PT(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y) : x(x), y(y) {}
    PT(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) : x(p.x), y(p.y) {}
    PT <B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x + p.x, y + p.y); }
    PT <B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x - p.x, y - p.y); }
    PT <B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">double</FONT></B> c) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x * c, y * c); }
    PT <B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">double</FONT></B> c) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x / c, y / c); }
};

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dot</FONT></B>(PT p, PT q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.x * q.x + p.y * q.y; }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dist2</FONT></B>(PT p, PT q) { <B><FONT COLOR="#A020F0">return</FONT></B> dot(p - q, p - q); }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(PT p, PT q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.x * q.y - p.y * q.x; }
ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;os, <B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) {
    <B><FONT COLOR="#A020F0">return</FONT></B> os &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; p.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B> &lt;&lt; p.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>;
}
<I><FONT COLOR="#B22222">// rotate a point CCW or CW around the origin
</FONT></I>PT <B><FONT COLOR="#0000FF">RotateCCW90</FONT></B>(PT p) { <B><FONT COLOR="#A020F0">return</FONT></B> PT(-p.y, p.x); }
PT <B><FONT COLOR="#0000FF">RotateCW90</FONT></B>(PT p) { <B><FONT COLOR="#A020F0">return</FONT></B> PT(p.y, -p.x); }
PT <B><FONT COLOR="#0000FF">RotateCCW</FONT></B>(PT p, <B><FONT COLOR="#228B22">double</FONT></B> t) {
    <B><FONT COLOR="#A020F0">return</FONT></B> PT(p.x * cos(t) - p.y * sin(t), p.x * sin(t) + p.y * cos(t));
}
<I><FONT COLOR="#B22222">// project point c onto line through a and b
</FONT></I><I><FONT COLOR="#B22222">// assuming a != b
</FONT></I>PT <B><FONT COLOR="#0000FF">ProjectPointLine</FONT></B>(PT a, PT b, PT c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a + (b - a) * dot(c - a, b - a) / dot(b - a, b - a);
}
<I><FONT COLOR="#B22222">// project point c onto line segment through a and b
</FONT></I>PT <B><FONT COLOR="#0000FF">ProjectPointSegment</FONT></B>(PT a, PT b, PT c) {
    <B><FONT COLOR="#228B22">double</FONT></B> r = dot(b - a, b - a);
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(r) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> a;
    r = dot(c - a, b - a) / r;
    <B><FONT COLOR="#A020F0">if</FONT></B> (r &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> a;
    <B><FONT COLOR="#A020F0">if</FONT></B> (r &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> b;
    <B><FONT COLOR="#A020F0">return</FONT></B> a + (b - a) * r;
}
<I><FONT COLOR="#B22222">// compute distance from c to segment between a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointSegment</FONT></B>(PT a, PT b, PT c) {
    <B><FONT COLOR="#A020F0">return</FONT></B> sqrt(dist2(c, ProjectPointSegment(a, b, c)));
}
<I><FONT COLOR="#B22222">// compute distance between point (x,y,z) and plane ax+by+cz=d
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointPlane</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y, <B><FONT COLOR="#228B22">double</FONT></B> z,
                          <B><FONT COLOR="#228B22">double</FONT></B> a, <B><FONT COLOR="#228B22">double</FONT></B> b, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(a * x + b * y + c * z - d) / sqrt(a * a + b * b + c * c);
}
<I><FONT COLOR="#B22222">// determine if lines from a to b and c to d are parallel or collinear
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesParallel</FONT></B>(PT a, PT b, PT c, PT d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(cross(b - a, c - d)) &lt; EPS;
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesCollinear</FONT></B>(PT a, PT b, PT c, PT d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> LinesParallel(a, b, c, d)
           &amp;&amp; fabs(cross(a - b, a - c)) &lt; EPS
           &amp;&amp; fabs(cross(c - d, c - a)) &lt; EPS;
}
<I><FONT COLOR="#B22222">// determine if line segment from a to b intersects with
</FONT></I><I><FONT COLOR="#B22222">// line segment from c to d
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">SegmentsIntersect</FONT></B>(PT a, PT b, PT c, PT d) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (LinesCollinear(a, b, c, d)) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(a, c) &lt; EPS || dist2(a, d) &lt; EPS ||
            dist2(b, c) &lt; EPS || dist2(b, d) &lt; EPS)
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        <B><FONT COLOR="#A020F0">if</FONT></B> (dot(c - a, c - b) &gt; 0 &amp;&amp; dot(d - a, d - b) &gt; 0 &amp;&amp; dot(c - b, d - b) &gt; 0)
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (cross(d - a, b - a) * cross(c - a, b - a) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B> (cross(a - c, d - c) * cross(b - c, d - c) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<I><FONT COLOR="#B22222">// compute intersection of line passing through a and b
</FONT></I><I><FONT COLOR="#B22222">// with line passing through c and d, assuming that unique
</FONT></I><I><FONT COLOR="#B22222">// intersection exists; for segment intersection, check if
</FONT></I><I><FONT COLOR="#B22222">// segments intersect first
</FONT></I>PT <B><FONT COLOR="#0000FF">ComputeLineIntersection</FONT></B>(PT a, PT b, PT c, PT d) {
    b = b - a;
    d = c - d;
    c = c - a;
    assert(dot(b, b) &gt; EPS &amp;&amp; dot(d, d) &gt; EPS);
    <B><FONT COLOR="#A020F0">return</FONT></B> a + b * cross(c, d) / cross(b, d);
}
<I><FONT COLOR="#B22222">// compute center of circle given three points
</FONT></I>PT <B><FONT COLOR="#0000FF">ComputeCircleCenter</FONT></B>(PT a, PT b, PT c) {
    b = (a + b) / 2;
    c = (a + c) / 2;
    <B><FONT COLOR="#A020F0">return</FONT></B> ComputeLineIntersection(b, b + RotateCW90(a - b), c, c + RotateCW90(a - c));
}
<I><FONT COLOR="#B22222">// determine if point is in a possibly non-convex polygon (by William
</FONT></I><I><FONT COLOR="#B22222">// Randolph Franklin); returns 1 for strictly interior points, 0 for
</FONT></I><I><FONT COLOR="#B22222">// strictly exterior points, and 0 or 1 for the remaining points.
</FONT></I><I><FONT COLOR="#B22222">// Note that it is possible to convert this into an *exact* test using
</FONT></I><I><FONT COLOR="#B22222">// integer arithmetic by taking care of the division appropriately
</FONT></I><I><FONT COLOR="#B22222">// (making sure to deal with signs properly) and then by writing exact
</FONT></I><I><FONT COLOR="#B22222">// tests for checking point on polygon boundary
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointInPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, PT q) {
    <B><FONT COLOR="#228B22">bool</FONT></B> c = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i + 1) % p.size();
        <B><FONT COLOR="#A020F0">if</FONT></B> ((p[i].y &lt;= q.y &amp;&amp; q.y &lt; p[j].y ||
             p[j].y &lt;= q.y &amp;&amp; q.y &lt; p[i].y) &amp;&amp;
            q.x &lt; p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))
            c = !c;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> c;
}
<I><FONT COLOR="#B22222">// determine if point is on the boundary of a polygon
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointOnPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, PT q) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++)
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(ProjectPointSegment(p[i], p[(i + 1) % p.size()], q), q) &lt; EPS)
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}
<I><FONT COLOR="#B22222">// compute intersection of line through points a and b with
</FONT></I><I><FONT COLOR="#B22222">// circle centered at c with radius r &gt; 0
</FONT></I>vector&lt;PT&gt; CircleLineIntersection(PT a, PT b, PT c, <B><FONT COLOR="#228B22">double</FONT></B> r) {
    vector&lt;PT&gt; ret;
    b = b - a;
    a = a - c;
    <B><FONT COLOR="#228B22">double</FONT></B> A = dot(b, b);
    <B><FONT COLOR="#228B22">double</FONT></B> B = dot(a, b);
    <B><FONT COLOR="#228B22">double</FONT></B> C = dot(a, a) - r * r;
    <B><FONT COLOR="#228B22">double</FONT></B> D = B * B - A * C;
    <B><FONT COLOR="#A020F0">if</FONT></B> (D &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    ret.push_back(c + a + b * (-B + sqrt(D + EPS)) / A);
    <B><FONT COLOR="#A020F0">if</FONT></B> (D &gt; EPS)
        ret.push_back(c + a + b * (-B - sqrt(D)) / A);
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// compute intersection of circle centered at a with radius r
</FONT></I><I><FONT COLOR="#B22222">// with circle centered at b with radius R
</FONT></I>vector&lt;PT&gt; CircleCircleIntersection(PT a, PT b, <B><FONT COLOR="#228B22">double</FONT></B> r, <B><FONT COLOR="#228B22">double</FONT></B> R) {
    vector&lt;PT&gt; ret;
    <B><FONT COLOR="#228B22">double</FONT></B> d = sqrt(dist2(a, b));
    <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; r + R || d + min(r, R) &lt; max(r, R)) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
    <B><FONT COLOR="#228B22">double</FONT></B> x = (d * d - R * R + r * r) / (2 * d);
    <B><FONT COLOR="#228B22">double</FONT></B> y = sqrt(r * r - x * x);
    PT v = (b - a) / d;
    ret.push_back(a + v * x + RotateCCW90(v) * y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (y &gt; 0)
        ret.push_back(a + v * x - RotateCCW90(v) * y);
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// This code computes the area or centroid of a (possibly nonconvex)
</FONT></I><I><FONT COLOR="#B22222">// polygon, assuming that the coordinates are listed in a clockwise or
</FONT></I><I><FONT COLOR="#B22222">// counterclockwise fashion.  Note that the centroid is often known as
</FONT></I><I><FONT COLOR="#B22222">// the &quot;center of gravity&quot; or &quot;center of mass&quot;.
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeSignedArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
    <B><FONT COLOR="#228B22">double</FONT></B> area = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i + 1) % p.size();
        area += p[i].x * p[j].y - p[j].x * p[i].y;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> area / 2.0;
}
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
    <B><FONT COLOR="#A020F0">return</FONT></B> fabs(ComputeSignedArea(p));
}
PT <B><FONT COLOR="#0000FF">ComputeCentroid</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
    PT c(0, 0);
    <B><FONT COLOR="#228B22">double</FONT></B> scale = 6.0 * ComputeSignedArea(p);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = (i + 1) % p.size();
        c = c + (p[i] + p[j]) * (p[i].x * p[j].y - p[j].x * p[i].y);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> c / scale;
}
<I><FONT COLOR="#B22222">// tests whether or not a given polygon (in CW or CCW order) is simple
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsSimple</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i + 1; k &lt; p.size(); k++) {
            <B><FONT COLOR="#228B22">int</FONT></B> j = (i + 1) % p.size();
            <B><FONT COLOR="#228B22">int</FONT></B> l = (k + 1) % p.size();
            <B><FONT COLOR="#A020F0">if</FONT></B> (i == l || j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (SegmentsIntersect(p[i], p[j], p[k], p[l]))
                <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

    <I><FONT COLOR="#B22222">// expected: (-5,2)
</FONT></I>    cerr &lt;&lt; RotateCCW90(PT(2, 5)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: (5,-2)
</FONT></I>    cerr &lt;&lt; RotateCW90(PT(2, 5)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: (-5,2)
</FONT></I>    cerr &lt;&lt; RotateCCW(PT(2, 5), M_PI / 2) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: (5,2)
</FONT></I>    cerr &lt;&lt; ProjectPointLine(PT(-5, -2), PT(10, 4), PT(3, 7)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: (5,2) (7.5,3) (2.5,1)
</FONT></I>    cerr &lt;&lt; ProjectPointSegment(PT(-5, -2), PT(10, 4), PT(3, 7)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; ProjectPointSegment(PT(7.5, 3), PT(10, 4), PT(3, 7)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; ProjectPointSegment(PT(-5, -2), PT(2.5, 1), PT(3, 7)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: 6.78903
</FONT></I>    cerr &lt;&lt; DistancePointPlane(4, -4, 3, 2, -2, 5, -8) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: 1 0 1
</FONT></I>    cerr &lt;&lt; LinesParallel(PT(1, 1), PT(3, 5), PT(2, 1), PT(4, 5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; LinesParallel(PT(1, 1), PT(3, 5), PT(2, 0), PT(4, 5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; LinesParallel(PT(1, 1), PT(3, 5), PT(5, 9), PT(7, 13)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: 0 0 1
</FONT></I>    cerr &lt;&lt; LinesCollinear(PT(1, 1), PT(3, 5), PT(2, 1), PT(4, 5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; LinesCollinear(PT(1, 1), PT(3, 5), PT(2, 0), PT(4, 5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; LinesCollinear(PT(1, 1), PT(3, 5), PT(5, 9), PT(7, 13)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: 1 1 1 0
</FONT></I>    cerr &lt;&lt; SegmentsIntersect(PT(0, 0), PT(2, 4), PT(3, 1), PT(-1, 3)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; SegmentsIntersect(PT(0, 0), PT(2, 4), PT(4, 3), PT(0, 5)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; SegmentsIntersect(PT(0, 0), PT(2, 4), PT(2, -1), PT(-2, 1)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; SegmentsIntersect(PT(0, 0), PT(2, 4), PT(5, 5), PT(1, 7)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: (1,2)
</FONT></I>    cerr &lt;&lt; ComputeLineIntersection(PT(0, 0), PT(2, 4), PT(3, 1), PT(-1, 3)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: (1,1)
</FONT></I>    cerr &lt;&lt; ComputeCircleCenter(PT(-3, 4), PT(6, 1), PT(4, 5)) &lt;&lt; endl;

    vector&lt;PT&gt; v;
    v.push_back(PT(0, 0));
    v.push_back(PT(5, 0));
    v.push_back(PT(5, 5));
    v.push_back(PT(0, 5));

    <I><FONT COLOR="#B22222">// expected: 1 1 1 0 0
</FONT></I>    cerr &lt;&lt; PointInPolygon(v, PT(2, 2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; PointInPolygon(v, PT(2, 0)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; PointInPolygon(v, PT(0, 2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; PointInPolygon(v, PT(5, 2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; PointInPolygon(v, PT(2, 5)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: 0 1 1 1 1
</FONT></I>    cerr &lt;&lt; PointOnPolygon(v, PT(2, 2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; PointOnPolygon(v, PT(2, 0)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; PointOnPolygon(v, PT(0, 2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; PointOnPolygon(v, PT(5, 2)) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>
         &lt;&lt; PointOnPolygon(v, PT(2, 5)) &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: (1,6)
</FONT></I>    <I><FONT COLOR="#B22222">//           (5,4) (4,5)
</FONT></I>    <I><FONT COLOR="#B22222">//           blank line
</FONT></I>    <I><FONT COLOR="#B22222">//           (4,5) (5,4)
</FONT></I>    <I><FONT COLOR="#B22222">//           blank line
</FONT></I>    <I><FONT COLOR="#B22222">//           (4,5) (5,4)
</FONT></I>    vector&lt;PT&gt; u = CircleLineIntersection(PT(0, 6), PT(2, 6), PT(1, 1), 5);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cerr &lt;&lt; endl;
    u = CircleLineIntersection(PT(0, 9), PT(9, 0), PT(1, 1), 5);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cerr &lt;&lt; endl;
    u = CircleCircleIntersection(PT(1, 1), PT(10, 10), 5, 5);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cerr &lt;&lt; endl;
    u = CircleCircleIntersection(PT(1, 1), PT(8, 8), 5, 5);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cerr &lt;&lt; endl;
    u = CircleCircleIntersection(PT(1, 1), PT(4.5, 4.5), 10, sqrt(2.0) / 2.0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cerr &lt;&lt; endl;
    u = CircleCircleIntersection(PT(1, 1), PT(4.5, 4.5), 5, sqrt(2.0) / 2.0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; u.size(); i++) cerr &lt;&lt; u[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cerr &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// area should be 5.0
</FONT></I>    <I><FONT COLOR="#B22222">// centroid should be (1.1666666, 1.166666)
</FONT></I>    PT pa[] = {PT(0, 0), PT(5, 0), PT(1, 1), PT(0, 5)};
    vector&lt;PT&gt; p(pa, pa + 4);
    PT c = ComputeCentroid(p);
    cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Area: &quot;</FONT></B> &lt;&lt; ComputeArea(p) &lt;&lt; endl;
    cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Centroid: &quot;</FONT></B> &lt;&lt; c &lt;&lt; endl;

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file22">
<H1>code/Geom3D.java 22/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file21">prev</A>][<A HREF="#file23">next</A>]
<PRE>
<B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">class</FONT></B> Geom3D {
  <I><FONT COLOR="#B22222">// distance from point (x, y, z) to plane aX + bY + cZ + d = 0
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptPlaneDist(<B><FONT COLOR="#A020F0">double</FONT></B> x, <B><FONT COLOR="#A020F0">double</FONT></B> y, <B><FONT COLOR="#A020F0">double</FONT></B> z,
      <B><FONT COLOR="#A020F0">double</FONT></B> a, <B><FONT COLOR="#A020F0">double</FONT></B> b, <B><FONT COLOR="#A020F0">double</FONT></B> c, <B><FONT COLOR="#A020F0">double</FONT></B> d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.abs(a*x + b*y + c*z + d) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <I><FONT COLOR="#B22222">// distance between parallel planes aX + bY + cZ + d1 = 0 and
</FONT></I>  <I><FONT COLOR="#B22222">// aX + bY + cZ + d2 = 0
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> planePlaneDist(<B><FONT COLOR="#A020F0">double</FONT></B> a, <B><FONT COLOR="#A020F0">double</FONT></B> b, <B><FONT COLOR="#A020F0">double</FONT></B> c,
      <B><FONT COLOR="#A020F0">double</FONT></B> d1, <B><FONT COLOR="#A020F0">double</FONT></B> d2) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.abs(d1 - d2) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <I><FONT COLOR="#B22222">// distance from point (px, py, pz) to line (x1, y1, z1)-(x2, y2, z2)
</FONT></I>  <I><FONT COLOR="#B22222">// (or ray, or segment; in the case of the ray, the endpoint is the
</FONT></I>  <I><FONT COLOR="#B22222">// first point)
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> LINE = 0;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> SEGMENT = 1;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> RAY = 2;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptLineDistSq(<B><FONT COLOR="#A020F0">double</FONT></B> x1, <B><FONT COLOR="#A020F0">double</FONT></B> y1, <B><FONT COLOR="#A020F0">double</FONT></B> z1,
      <B><FONT COLOR="#A020F0">double</FONT></B> x2, <B><FONT COLOR="#A020F0">double</FONT></B> y2, <B><FONT COLOR="#A020F0">double</FONT></B> z2, <B><FONT COLOR="#A020F0">double</FONT></B> px, <B><FONT COLOR="#A020F0">double</FONT></B> py, <B><FONT COLOR="#A020F0">double</FONT></B> pz,
      <B><FONT COLOR="#A020F0">int</FONT></B> type) {
    <B><FONT COLOR="#A020F0">double</FONT></B> pd2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2);
    
    <B><FONT COLOR="#A020F0">double</FONT></B> x, y, z;
    <B><FONT COLOR="#A020F0">if</FONT></B> (pd2 == 0) {
      x = x1;
      y = y1;
      z = z1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      <B><FONT COLOR="#A020F0">double</FONT></B> u = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1) + (pz-z1)*(z2-z1)) / pd2;
      x = x1 + u * (x2 - x1);
      y = y1 + u * (y2 - y1);
      z = z1 + u * (z2 - z1);
      <B><FONT COLOR="#A020F0">if</FONT></B> (type != LINE &amp;&amp; u &lt; 0) {
        x = x1;
        y = y1;
        z = z1;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (type == SEGMENT &amp;&amp; u &gt; 1.0) {
        x = x2;
        y = y2;
        z = z2;
      }
    }
    
    <B><FONT COLOR="#A020F0">return</FONT></B> (x-px)*(x-px) + (y-py)*(y-py) + (z-pz)*(z-pz);
  }
  
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptLineDist(<B><FONT COLOR="#A020F0">double</FONT></B> x1, <B><FONT COLOR="#A020F0">double</FONT></B> y1, <B><FONT COLOR="#A020F0">double</FONT></B> z1,
      <B><FONT COLOR="#A020F0">double</FONT></B> x2, <B><FONT COLOR="#A020F0">double</FONT></B> y2, <B><FONT COLOR="#A020F0">double</FONT></B> z2, <B><FONT COLOR="#A020F0">double</FONT></B> px, <B><FONT COLOR="#A020F0">double</FONT></B> py, <B><FONT COLOR="#A020F0">double</FONT></B> pz,
      <B><FONT COLOR="#A020F0">int</FONT></B> type) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.sqrt(ptLineDistSq(x1, y1, z1, x2, y2, z2, px, py, pz, type));
  }
}
</PRE>
<HR>
<A NAME="file23">
<H1>code/Delaunay.cc 23/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file22">prev</A>][<A HREF="#file24">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Slow but simple Delaunay triangulation. Does not handle
</FONT></I><I><FONT COLOR="#B22222">// degenerate cases (from O'Rourke, Computational Geometry in C)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^4)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    x[] = x-coordinates
</FONT></I><I><FONT COLOR="#B22222">//           y[] = y-coordinates
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   triples = a vector containing m triples of indices
</FONT></I><I><FONT COLOR="#B22222">//                     corresponding to triangle vertices
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include&lt;vector&gt;
</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;

<B><FONT COLOR="#228B22">struct</FONT></B> triple {
    <B><FONT COLOR="#228B22">int</FONT></B> i, j, k;
    triple() {}
    triple(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j, <B><FONT COLOR="#228B22">int</FONT></B> k) : i(i), j(j), k(k) {}
};

vector&lt;triple&gt; delaunayTriangulation(vector&lt;T&gt; &amp;x, vector&lt;T&gt; &amp;y) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = x.size();
    vector&lt;T&gt; z(n);
    vector&lt;triple&gt; ret;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
        z[i] = x[i] * x[i] + y[i] * y[i];

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n - 2; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i + 1; j &lt; n; j++) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i + 1; k &lt; n; k++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
                <B><FONT COLOR="#228B22">double</FONT></B> xn = (y[j] - y[i]) * (z[k] - z[i]) - (y[k] - y[i]) * (z[j] - z[i]);
                <B><FONT COLOR="#228B22">double</FONT></B> yn = (x[k] - x[i]) * (z[j] - z[i]) - (x[j] - x[i]) * (z[k] - z[i]);
                <B><FONT COLOR="#228B22">double</FONT></B> zn = (x[j] - x[i]) * (y[k] - y[i]) - (x[k] - x[i]) * (y[j] - y[i]);
                <B><FONT COLOR="#228B22">bool</FONT></B> flag = zn &lt; 0;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> m = 0; flag &amp;&amp; m &lt; n; m++)
                    flag = flag &amp;&amp; ((x[m] - x[i]) * xn +
                                    (y[m] - y[i]) * yn +
                                    (z[m] - z[i]) * zn &lt;= 0);
                <B><FONT COLOR="#A020F0">if</FONT></B> (flag) ret.push_back(triple(i, j, k));
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    T xs[] = {0, 0, 1, 0.9};
    T ys[] = {0, 1, 0, 0.9};
    vector&lt;T&gt; x(&amp;xs[0], &amp;xs[4]), y(&amp;ys[0], &amp;ys[4]);
    vector&lt;triple&gt; tri = delaunayTriangulation(x, y);

    <I><FONT COLOR="#B22222">//expected: 0 1 3
</FONT></I>    <I><FONT COLOR="#B22222">//          0 3 2
</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> i;
    <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; tri.size(); i++)
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d\n&quot;</FONT></B>, tri[i].i, tri[i].j, tri[i].k);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file24">
<H1>code/Euclid.cc 24/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file23">prev</A>][<A HREF="#file25">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This is a collection of useful code for solving problems that
</FONT></I><I><FONT COLOR="#B22222">// involve modular linear equations.  Note that all of the
</FONT></I><I><FONT COLOR="#B22222">// algorithms described here work on nonnegative integers.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<I><FONT COLOR="#B22222">// return a % b (positive value)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> ((a % b) + b) % b;
}
<I><FONT COLOR="#B22222">// computes gcd(a,b)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">gcd</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
        <B><FONT COLOR="#228B22">int</FONT></B> t = a % b;
        a = b;
        b = t;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> a;
}
<I><FONT COLOR="#B22222">// computes lcm(a,b)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lcm</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> a / gcd(a, b) * b;
}
<I><FONT COLOR="#B22222">// (a^b) mod m via successive squaring
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">powermod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> m) {
    <B><FONT COLOR="#228B22">int</FONT></B> ret = 1;
    <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (b &amp; 1) ret = mod(ret * a, m);
        a = mod(a * a, m);
        b &gt;&gt;= 1;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// Finds two integers $x$ and $y$, such that $ax+by=\gcd(a,b)$. If
</FONT></I><I><FONT COLOR="#B22222">// If $a$ and $b$ are coprime, then $x$ is the inverse of $a \pmod{b}$.
</FONT></I><I><FONT COLOR="#B22222">// Returns gcd(a, b)
</FONT></I>ll <B><FONT COLOR="#0000FF">extended_euclid</FONT></B>(ll a, ll b, ll &amp;x, ll &amp;y) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!b) <B><FONT COLOR="#A020F0">return</FONT></B> x = 1, y = 0, a;
    ll d = euclid(b, a % b, y, x);
    <B><FONT COLOR="#A020F0">return</FONT></B> y -= a/b * x, d;
}
<I><FONT COLOR="#B22222">// finds all solutions to ax = b (mod n)
</FONT></I>VI <B><FONT COLOR="#0000FF">modular_linear_equation_solver</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;
    VI ret;
    <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(a, n, x, y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(b % g)) {
        x = mod(x * (b / g), n);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; g; i++)
            ret.push_back(mod(x + i * (n / g), n));
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// computes b such that ab = 1 (mod n), returns -1 on failure
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod_inverse</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;
    <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(a, n, x, y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (g &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    <B><FONT COLOR="#A020F0">return</FONT></B> mod(x, n);
}
<I><FONT COLOR="#B22222">// compute mod inverse of all numbers up to n
</FONT></I>vector&lt;ll&gt; precompute_inv_mod(<B><FONT COLOR="#228B22">int</FONT></B> n, ll mod) {
    vector&lt;ll&gt; inv(n + 1);
    inv[1] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt;= n; ++i) {
        inv[i] = mod - (mod / i) * inv[mod % i] % mod;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> inv;
}
<I><FONT COLOR="#B22222">// Chinese remainder theorem (special case): find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % m1 = r1, z % m2 = r2.  Here, z is unique modulo M = lcm(m1, m2).
</FONT></I><I><FONT COLOR="#B22222">// Return (z, M).  On failure, M = -1.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> m1, <B><FONT COLOR="#228B22">int</FONT></B> r1, <B><FONT COLOR="#228B22">int</FONT></B> m2, <B><FONT COLOR="#228B22">int</FONT></B> r2) {
    <B><FONT COLOR="#228B22">int</FONT></B> s, t;
    <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(m1, m2, s, t);
    <B><FONT COLOR="#A020F0">if</FONT></B> (r1 % g != r2 % g) <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(0, -1);
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(mod(s * r2 * m1 + t * r1 * m2, m1 * m2) / g, m1 * m2 / g);
}
<I><FONT COLOR="#B22222">// Chinese remainder theorem: find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % m[i] = r[i] for all i.  Note that the solution is
</FONT></I><I><FONT COLOR="#B22222">// unique modulo M = lcm_i (m[i]).  Return (z, M). On 
</FONT></I><I><FONT COLOR="#B22222">// failure, M = -1. Note that we do not require the a[i]'s
</FONT></I><I><FONT COLOR="#B22222">// to be relatively prime.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VI &amp;m, <B><FONT COLOR="#228B22">const</FONT></B> VI &amp;r) {
    PII ret = make_pair(r[0], m[0]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; m.size(); i++) {
        ret = chinese_remainder_theorem(ret.second, ret.first, m[i], r[i]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (ret.second == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// computes x and y such that ax + by = c
</FONT></I><I><FONT COLOR="#B22222">// returns whether the solution exists
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">linear_diophantine</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> c, <B><FONT COLOR="#228B22">int</FONT></B> &amp;x, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!a &amp;&amp; !b) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (c) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        x = 0; y = 0;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!a) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (c % b) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        x = 0; y = c / b;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!b) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (c % a) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        x = c / a; y = 0;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#228B22">int</FONT></B> g = gcd(a, b);
    <B><FONT COLOR="#A020F0">if</FONT></B> (c % g) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    x = c / g * mod_inverse(a / g, b / g);
    y = (c - a * x) / b;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;
    <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(14, 30, x, y);
    cout &lt;&lt; g &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; y &lt;&lt; endl; <I><FONT COLOR="#B22222">//2 -2 1
</FONT></I>    VI sols = modular_linear_equation_solver(14, 30, 100);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sols.size(); i++) cout &lt;&lt; sols[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>; <I><FONT COLOR="#B22222">// 95 451
</FONT></I>    cout &lt;&lt; endl;
    cout &lt;&lt; mod_inverse(8, 9) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 8
</FONT></I>    PII ret = chinese_remainder_theorem(VI({3, 5, 7}), VI({2, 3, 2}));
    cout &lt;&lt; ret.first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; ret.second &lt;&lt; endl; <I><FONT COLOR="#B22222">// 23 105
</FONT></I>    ret = chinese_remainder_theorem(VI({4, 6}), VI({3, 5}));
    cout &lt;&lt; ret.first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; ret.second &lt;&lt; endl; <I><FONT COLOR="#B22222">// 11 12
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (!linear_diophantine(7, 2, 5, x, y)) cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;ERROR&quot;</FONT></B> &lt;&lt; endl;
    cout &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; y &lt;&lt; endl; <I><FONT COLOR="#B22222">// 5 -15
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file25">
<H1>code/GaussJordan.cc 25/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file24">prev</A>][<A HREF="#file26">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Gauss-Jordan elimination with full pivoting.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Uses:
</FONT></I><I><FONT COLOR="#B22222">//   (1) solving systems of linear equations (AX=B)
</FONT></I><I><FONT COLOR="#B22222">//   (2) inverting matrices (AX=I)
</FONT></I><I><FONT COLOR="#B22222">//   (3) computing determinants of square matrices
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxn matrix
</FONT></I><I><FONT COLOR="#B22222">//           b[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   X      = an nxm matrix (stored in b[][])
</FONT></I><I><FONT COLOR="#B22222">//           A^{-1} = an nxn matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns determinant of a[][]
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-10;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
T GaussJordan(VVT &amp;a, VVT &amp;b) {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = b[0].size();
    VI irow(n), icol(n), ipiv(n);
    T det = 1;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> pj = -1, pk = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[j])
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++)
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[k])
                        <B><FONT COLOR="#A020F0">if</FONT></B> (pj == -1 || fabs(a[j][k]) &gt; fabs(a[pj][pk])) {
                            pj = j;
                            pk = k;
                        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[pj][pk]) &lt; EPS) {
            cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Matrix is singular.&quot;</FONT></B> &lt;&lt; endl;
            exit(0);
        }
        ipiv[pk]++;
        swap(a[pj], a[pk]);
        swap(b[pj], b[pk]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (pj != pk) det *= -1;
        irow[i] = pj;
        icol[i] = pk;

        T c = 1.0 / a[pk][pk];
        det *= a[pk][pk];
        a[pk][pk] = 1.0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) a[pk][p] *= c;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; m; p++) b[pk][p] *= c;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (p != pk) {
                c = a[p][pk];
                a[p][pk] = 0;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; n; q++) a[p][q] -= a[pk][q] * c;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; m; q++) b[p][q] -= b[pk][q] * c;
            }
    }

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = n - 1; p &gt;= 0; p--)
        <B><FONT COLOR="#A020F0">if</FONT></B> (irow[p] != icol[p]) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) swap(a[k][irow[p]], a[k][icol[p]]);
        }

    <B><FONT COLOR="#A020F0">return</FONT></B> det;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 4;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 2;
    <B><FONT COLOR="#228B22">double</FONT></B> A[n][n] = {{1, 2, 3, 4},
                      {1, 0, 1, 0},
                      {5, 3, 2, 4},
                      {6, 1, 4, 6}};
    <B><FONT COLOR="#228B22">double</FONT></B> B[n][m] = {{1, 2},
                      {4, 3},
                      {5, 6},
                      {8, 7}};
    VVT a(n), b(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        a[i] = VT(A[i], A[i] + n);
        b[i] = VT(B[i], B[i] + m);
    }

    <B><FONT COLOR="#228B22">double</FONT></B> det = GaussJordan(a, b);

    <I><FONT COLOR="#B22222">// expected: 60
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Determinant: &quot;</FONT></B> &lt;&lt; det &lt;&lt; endl;

    <I><FONT COLOR="#B22222">// expected: -0.233333 0.166667 0.133333 0.0666667
</FONT></I>    <I><FONT COLOR="#B22222">//           0.166667 0.166667 0.333333 -0.333333
</FONT></I>    <I><FONT COLOR="#B22222">//           0.233333 0.833333 -0.133333 -0.0666667
</FONT></I>    <I><FONT COLOR="#B22222">//           0.05 -0.75 -0.1 0.2
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Inverse: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }

    <I><FONT COLOR="#B22222">// expected: 1.63333 1.3
</FONT></I>    <I><FONT COLOR="#B22222">//           -0.166667 0.5
</FONT></I>    <I><FONT COLOR="#B22222">//           2.36667 1.7
</FONT></I>    <I><FONT COLOR="#B22222">//           -1.85 -1.35
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Solution: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++)
            cout &lt;&lt; b[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }
}
</PRE>
<HR>
<A NAME="file26">
<H1>code/ReducedRowEchelonForm.cc 26/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file25">prev</A>][<A HREF="#file27">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Reduced row echelon form via Gauss-Jordan elimination 
</FONT></I><I><FONT COLOR="#B22222">// with partial pivoting.  This can be used for computing
</FONT></I><I><FONT COLOR="#B22222">// the rank of a matrix.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   rref[][] = an nxm matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns rank of a[][]
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPSILON = 1e-10;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">rref</FONT></B>(VVT &amp;a) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
    <B><FONT COLOR="#228B22">int</FONT></B> m = a[0].size();
    <B><FONT COLOR="#228B22">int</FONT></B> r = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt; m &amp;&amp; r &lt; n; c++) {
        <B><FONT COLOR="#228B22">int</FONT></B> j = r;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = r + 1; i &lt; n; i++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[i][c]) &gt; fabs(a[j][c])) j = i;
        <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[j][c]) &lt; EPSILON) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        swap(a[j], a[r]);

        T s = 1.0 / a[r][c];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) a[r][j] *= s;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (i != r) {
                T t = a[i][c];
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) a[i][j] -= t * a[r][j];
            }
        r++;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> r;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 5, m = 4;
    <B><FONT COLOR="#228B22">double</FONT></B> A[n][m] = {
            {16, 2,  3,  13},
            {5,  11, 10, 8},
            {9,  7,  6,  12},
            {4,  14, 15, 1},
            {13, 21, 21, 13}};
    VVT a(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
        a[i] = VT(A[i], A[i] + m);

    <B><FONT COLOR="#228B22">int</FONT></B> rank = rref(a);

    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Rank: &quot;</FONT></B> &lt;&lt; rank &lt;&lt; endl; <I><FONT COLOR="#B22222">// 3
</FONT></I>
    <I><FONT COLOR="#B22222">// expected: 1 0 0 1
</FONT></I>    <I><FONT COLOR="#B22222">//           0 1 0 3
</FONT></I>    <I><FONT COLOR="#B22222">//           0 0 1 -3
</FONT></I>    <I><FONT COLOR="#B22222">//           0 0 0 3.10862e-15
</FONT></I>    <I><FONT COLOR="#B22222">//           0 0 0 2.22045e-15
</FONT></I>    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;rref: &quot;</FONT></B> &lt;&lt; endl;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 5; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 4; j++)
            cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
        cout &lt;&lt; endl;
    }
}
</PRE>
<HR>
<A NAME="file27">
<H1>code/FFT_new.cc 27/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file26">prev</A>][<A HREF="#file28">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

<B><FONT COLOR="#228B22">struct</FONT></B> cpx {
    cpx() {}
    cpx(<B><FONT COLOR="#228B22">double</FONT></B> aa) : a(aa), b(0) {}
    cpx(<B><FONT COLOR="#228B22">double</FONT></B> aa, <B><FONT COLOR="#228B22">double</FONT></B> bb) : a(aa), b(bb) {}
    <B><FONT COLOR="#228B22">double</FONT></B> a, b;
    <B><FONT COLOR="#228B22">double</FONT></B> modsq(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> a * a + b * b;
    }
    cpx bar(<B><FONT COLOR="#228B22">void</FONT></B>) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> cpx(a, -b);
    }
};

cpx <B><FONT COLOR="#A020F0">operator</FONT></B>+(cpx a, cpx b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> cpx(a.a + b.a, a.b + b.b);
}
cpx <B><FONT COLOR="#A020F0">operator</FONT></B>*(cpx a, cpx b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> cpx(a.a * b.a - a.b * b.b, a.a * b.b + a.b * b.a);
}
cpx <B><FONT COLOR="#A020F0">operator</FONT></B>/(cpx a, cpx b) {
    cpx r = a * b.bar();
    <B><FONT COLOR="#A020F0">return</FONT></B> cpx(r.a / b.modsq(), r.b / b.modsq());
}
cpx <B><FONT COLOR="#0000FF">EXP</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> theta) {
    <B><FONT COLOR="#A020F0">return</FONT></B> cpx(cos(theta), sin(theta));
}
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> two_pi = 4 * acos(0);
<I><FONT COLOR="#B22222">// in:     input array
</FONT></I><I><FONT COLOR="#B22222">// out:    output array
</FONT></I><I><FONT COLOR="#B22222">// step:   {SET TO 1} (used internally)
</FONT></I><I><FONT COLOR="#B22222">// size:   length of the input/output {MUST BE A POWER OF 2}
</FONT></I><I><FONT COLOR="#B22222">// dir:    either plus or minus one (direction of the FFT, 1 is first)
</FONT></I><I><FONT COLOR="#B22222">// RESULT: out[k] = \sum_{j=0}^{size - 1} in[j] * exp(dir * 2pi * i * j * k / size)
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">FFT</FONT></B>(cpx *in, cpx *out, <B><FONT COLOR="#228B22">int</FONT></B> step, <B><FONT COLOR="#228B22">int</FONT></B> size, <B><FONT COLOR="#228B22">int</FONT></B> dir) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (size &lt; 1) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (size == 1) {
        out[0] = in[0];
        <B><FONT COLOR="#A020F0">return</FONT></B>;
    }
    FFT(in, out, step * 2, size / 2, dir);
    FFT(in + step, out + size / 2, step * 2, size / 2, dir);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; size / 2; i++) {
        cpx even = out[i];
        cpx odd = out[i + size / 2];
        out[i] = even + EXP(dir * two_pi * i / size) * odd;
        out[i + size / 2] = even + EXP(dir * two_pi * (i + size / 2) / size) * odd;
    }
}

<I><FONT COLOR="#B22222">// Usage:
</FONT></I><I><FONT COLOR="#B22222">// f[0...N-1] and g[0..N-1] are numbers
</FONT></I><I><FONT COLOR="#B22222">// Want to compute the convolution h, defined by
</FONT></I><I><FONT COLOR="#B22222">// h[n] = sum of f[k]g[n-k] (k = 0, ..., N-1).
</FONT></I><I><FONT COLOR="#B22222">// Here, the index is cyclic; f[-1] = f[N-1], f[-2] = f[N-2], etc.
</FONT></I><I><FONT COLOR="#B22222">// Let F[0...N-1] be FFT(f), and similarly, define G and H.
</FONT></I><I><FONT COLOR="#B22222">// The convolution theorem says H[n] = F[n]G[n] (element-wise product).
</FONT></I><I><FONT COLOR="#B22222">// To compute h[] in O(N log N) time, do the following:
</FONT></I><I><FONT COLOR="#B22222">//   1. Compute F and G (pass dir = 1 as the argument).
</FONT></I><I><FONT COLOR="#B22222">//   2. Get H by element-wise multiplying F and G.
</FONT></I><I><FONT COLOR="#B22222">//   3. Get h by taking the inverse FFT (use dir = -1 as the argument)
</FONT></I><I><FONT COLOR="#B22222">//      and *dividing by N*. DO NOT FORGET THIS SCALING FACTOR.
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) {
    printf(<B><FONT COLOR="#BC8F8F">&quot;If rows come in identical pairs, then everything works.\n&quot;</FONT></B>);

    cpx a[8] = {0, 1, cpx(1, 3), cpx(0, 5), 1, 0, 2, 0};
    cpx b[8] = {1, cpx(0, -2), cpx(0, 1), 3, -1, -3, 1, -2};
    cpx A[8];
    cpx B[8];
    FFT(a, A, 1, 8, 1);
    FFT(b, B, 1, 8, 1);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;%7.2lf%7.2lf&quot;</FONT></B>, A[i].a, A[i].b);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++) {
        cpx Ai(0, 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 8; j++) {
            Ai = Ai + a[j] * EXP(j * i * two_pi / 8);
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;%7.2lf%7.2lf&quot;</FONT></B>, Ai.a, Ai.b);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);

    cpx AB[8];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++)
        AB[i] = A[i] * B[i];
    cpx aconvb[8];
    FFT(AB, aconvb, 1, 8, -1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++)
        aconvb[i] = aconvb[i] / 8;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++) {
        printf(<B><FONT COLOR="#BC8F8F">&quot;%7.2lf%7.2lf&quot;</FONT></B>, aconvb[i].a, aconvb[i].b);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; i++) {
        cpx aconvbi(0, 0);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 8; j++) {
            aconvbi = aconvbi + a[j] * b[(8 + i - j) % 8];
        }
        printf(<B><FONT COLOR="#BC8F8F">&quot;%7.2lf%7.2lf&quot;</FONT></B>, aconvbi.a, aconvbi.b);
    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

</PRE>
<HR>
<A NAME="file28">
<H1>code/Simplex.cc 28/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file27">prev</A>][<A HREF="#file29">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Two-phase simplex algorithm for solving linear programs of the form
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//     maximize     c^T x
</FONT></I><I><FONT COLOR="#B22222">//     subject to   Ax &lt;= b
</FONT></I><I><FONT COLOR="#B22222">//                  x &gt;= 0
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: A -- an m x n matrix
</FONT></I><I><FONT COLOR="#B22222">//        b -- an m-dimensional vector
</FONT></I><I><FONT COLOR="#B22222">//        c -- an n-dimensional vector
</FONT></I><I><FONT COLOR="#B22222">//        x -- a vector where the optimal solution will be stored
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT: value of the optimal solution (infinity if unbounded
</FONT></I><I><FONT COLOR="#B22222">//         above, nan if infeasible)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// To use this code, create an LPSolver object with A, b, and c as
</FONT></I><I><FONT COLOR="#B22222">// arguments.  Then, call Solve(x).
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> DOUBLE;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;DOUBLE&gt; VD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VD&gt; VVD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;

<B><FONT COLOR="#228B22">const</FONT></B> DOUBLE EPS = 1e-9;

<B><FONT COLOR="#228B22">struct</FONT></B> LPSolver {
  <B><FONT COLOR="#228B22">int</FONT></B> m, n;
  VI B, N;
  VVD D;

  LPSolver(<B><FONT COLOR="#228B22">const</FONT></B> VVD &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> VD &amp;b, <B><FONT COLOR="#228B22">const</FONT></B> VD &amp;c) :
    m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) D[i][j] = A[i][j];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) { N[j] = j; D[m][j] = -c[j]; }
    N[n] = -1; D[m + 1][n] = 1;
  }

  <B><FONT COLOR="#228B22">void</FONT></B> Pivot(<B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> s) {
    <B><FONT COLOR="#228B22">double</FONT></B> inv = 1.0 / D[r][s];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m + 2; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (i != r)
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n + 2; j++) <B><FONT COLOR="#A020F0">if</FONT></B> (j != s)
        D[i][j] -= D[r][j] * D[i][s] * inv;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n + 2; j++) <B><FONT COLOR="#A020F0">if</FONT></B> (j != s) D[r][j] *= inv;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m + 2; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (i != r) D[i][s] *= -inv;
    D[r][s] = inv;
    swap(B[r], N[s]);
  }

  <B><FONT COLOR="#228B22">bool</FONT></B> Simplex(<B><FONT COLOR="#228B22">int</FONT></B> phase) {
    <B><FONT COLOR="#228B22">int</FONT></B> x = phase == 1 ? m + 1 : m;
    <B><FONT COLOR="#A020F0">while</FONT></B> (true) {
      <B><FONT COLOR="#228B22">int</FONT></B> s = -1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= n; j++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (phase == 2 &amp;&amp; N[j] == -1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (s == -1 || D[x][j] &lt; D[x][s] || D[x][j] == D[x][s] &amp;&amp; N[j] &lt; N[s]) s = j;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (D[x][s] &gt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> true;
      <B><FONT COLOR="#228B22">int</FONT></B> r = -1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (D[i][s] &lt; EPS) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (r == -1 || D[i][n + 1] / D[i][s] &lt; D[r][n + 1] / D[r][s] ||
          (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) &amp;&amp; B[i] &lt; B[r]) r = i;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (r == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
      Pivot(r, s);
    }
  }

  DOUBLE Solve(VD &amp;x) {
    <B><FONT COLOR="#228B22">int</FONT></B> r = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (D[i][n + 1] &lt; D[r][n + 1]) r = i;
    <B><FONT COLOR="#A020F0">if</FONT></B> (D[r][n + 1] &lt; -EPS) {
      Pivot(r, n);
      <B><FONT COLOR="#A020F0">if</FONT></B> (!Simplex(1) || D[m + 1][n + 1] &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> -numeric_limits&lt;DOUBLE&gt;::infinity();
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (B[i] == -1) {
        <B><FONT COLOR="#228B22">int</FONT></B> s = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= n; j++)
          <B><FONT COLOR="#A020F0">if</FONT></B> (s == -1 || D[i][j] &lt; D[i][s] || D[i][j] == D[i][s] &amp;&amp; N[j] &lt; N[s]) s = j;
        Pivot(i, s);
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!Simplex(2)) <B><FONT COLOR="#A020F0">return</FONT></B> numeric_limits&lt;DOUBLE&gt;::infinity();
    x = VD(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (B[i] &lt; n) x[B[i]] = D[i][n + 1];
    <B><FONT COLOR="#A020F0">return</FONT></B> D[m][n + 1];
  }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 4;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 3;
  DOUBLE _A[m][n] = {
    { 6, -1, 0 },
    { -1, -5, 0 },
    { 1, 5, 1 },
    { -1, -5, -1 }
  };
  DOUBLE _b[m] = { 10, -4, 5, -5 };
  DOUBLE _c[n] = { 1, -1, 0 };

  VVD A(m);
  VD b(_b, _b + m);
  VD c(_c, _c + n);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) A[i] = VD(_A[i], _A[i] + n);

  LPSolver solver(A, b, c);
  VD x;
  DOUBLE value = solver.Solve(x);

  cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;VALUE: &quot;</FONT></B> &lt;&lt; value &lt;&lt; endl; <I><FONT COLOR="#B22222">// VALUE: 1.29032
</FONT></I>  cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;SOLUTION:&quot;</FONT></B>; <I><FONT COLOR="#B22222">// SOLUTION: 1.74194 0.451613 1
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (size_t i = 0; i &lt; x.size(); i++) cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; x[i];
  cerr &lt;&lt; endl;
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file29">
<H1>code/CalculatePhi.cpp 29/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file28">prev</A>][<A HREF="#file30">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Author: Hakan Terelius
 * Date: 2009-09-25
 * License: CC0
 * Description: Precompute the number of positive integers coprime to N up to a given limit.
 * - The sum phi(d) for all divisors d of n is equal to n.
 * - The sum of all positive numbers less than n that are coprime to n is n phi(n) / 2 (n &gt; 1)
 * - For any a, n coprime, a^(phi(n)) = 1 mod n
 * - Specifically, for any prime p, any number a, a^{p-1} = 1 mod p
 * Status: Tested
 */</FONT></I>
#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">once</FONT>

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> LIM = 5000000;
<B><FONT COLOR="#228B22">int</FONT></B> phi[LIM];

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">calculatePhi</FONT></B>() {
    rep(i,0,LIM) phi[i] = i&amp;1 ? i : i/2;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 3; i &lt; LIM; i += 2) <B><FONT COLOR="#A020F0">if</FONT></B>(phi[i] == i)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i; j &lt; LIM; j += i) phi[j] -= phi[j] / i;
}</PRE>
<HR>
<A NAME="file30">
<H1>code/Partitions.cpp 30/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file29">prev</A>][<A HREF="#file31">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;
<I><FONT COLOR="#B22222">// Ways to write n as a sum of positive numbers.
</FONT></I><I><FONT COLOR="#B22222">// parition(4)=5 because 4 = 3 + 1 = 2 + 2 = 2 + 1 + 1 = 1 + 1 + 1 + 1
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">partition</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#A020F0">if</FONT></B>(n==0) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
    assert(n &gt; 0);
    vi dp = vi(n + 1);
    dp[0] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1, r = 1; i - (3 * j * j - j) / 2 &gt;= 0; j++, r *= -1) {
            dp[i] += dp[i - (3 * j * j - j) / 2] * r;
            <B><FONT COLOR="#A020F0">if</FONT></B> (i - (3 * j * j + j) / 2 &gt;= 0) {
                dp[i] += dp[i - (3 * j * j + j) / 2] * r;
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> dp[n];
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <I><FONT COLOR="#B22222">// 0 1, 1 1, 2 2, 3 3, 4 5, 5 7, 6 11, 7 15, 8 22, 9 30, 10 42
</FONT></I>    <I><FONT COLOR="#B22222">// 11 56, 12 77, 13 101, 14 135, 15 176, 16 231, 17 297
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= 17; ++i) {
        cout &lt;&lt; i &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; partition(i) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file31">
<H1>code/BellmanFord.cc 31/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file30">prev</A>][<A HREF="#file32">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This function runs the Bellman-Ford algorithm for single source
</FONT></I><I><FONT COLOR="#B22222">// shortest paths with negative edge weights.  The function returns
</FONT></I><I><FONT COLOR="#B22222">// false if a negative weight cycle is detected.  Otherwise, the
</FONT></I><I><FONT COLOR="#B22222">// function returns true and dist[i] is the length of the shortest
</FONT></I><I><FONT COLOR="#B22222">// path from start to i.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   start, w[i][j] = cost of edge from i to j
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  dist[i] = min weight path from start to i
</FONT></I><I><FONT COLOR="#B22222">//            prev[i] = previous node on the best path from the
</FONT></I><I><FONT COLOR="#B22222">//                      start node   
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">BellmanFord</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVT &amp;w, VT &amp;dist, VI &amp;prev, <B><FONT COLOR="#228B22">int</FONT></B> start) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
    prev = VI(n, -1);
    dist = VT(n, 1000000000);
    dist[start] = 0;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (dist[j] &gt; dist[i] + w[i][j]) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (k == n - 1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
                    dist[j] = dist[i] + w[i][j];
                    prev[j] = i;
                }
            }
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
</PRE>
<HR>
<A NAME="file32">
<H1>code/TopologicalSort.cc 32/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file31">prev</A>][<A HREF="#file33">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This function uses performs a non-recursive topological sort.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^2).  If you use adjacency lists (vector&lt;map&lt;int&gt; &gt;),
</FONT></I><I><FONT COLOR="#B22222">//               the running time is reduced to O(|E|).
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   w[i][j] = 1 if i should come before j, 0 otherwise
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  a permutation of 0,...,n-1 (stored in a vector)
</FONT></I><I><FONT COLOR="#B22222">//            which represents an ordering of the nodes which
</FONT></I><I><FONT COLOR="#B22222">//            is consistent with w
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// If no ordering is possible, false is returned.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">TopologicalSort</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVI &amp;w, VI &amp;order) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
    VI parents(n);
    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    order.clear();

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (w[j][i]) parents[i]++;
        <B><FONT COLOR="#A020F0">if</FONT></B> (parents[i] == 0) q.push(i);
    }

    <B><FONT COLOR="#A020F0">while</FONT></B> (q.size() &gt; 0) {
        <B><FONT COLOR="#228B22">int</FONT></B> i = q.front();
        q.pop();
        order.push_back(i);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (w[i][j]) {
                parents[j]--;
                <B><FONT COLOR="#A020F0">if</FONT></B> (parents[j] == 0) q.push(j);
            }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> (order.size() == n);
}
</PRE>
<HR>
<A NAME="file33">
<H1>code/FastDijkstra.cc 33/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file32">prev</A>][<A HREF="#file34">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Implementation of Dijkstra's algorithm using adjacency lists
</FONT></I><I><FONT COLOR="#B22222">// and priority queue for efficiency.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|E| log |V|)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>

using namespace std;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 2000000000;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> N, s, t;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d%d&quot;</FONT></B>, &amp;N, &amp;s, &amp;t);
    vector&lt;vector&lt;PII&gt; &gt; edges(N);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> M;
        scanf(<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;M);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; M; j++) {
            <B><FONT COLOR="#228B22">int</FONT></B> vertex, dist;
            scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;vertex, &amp;dist);
            edges[i].push_back(make_pair(dist, vertex)); <I><FONT COLOR="#B22222">// note order of arguments here
</FONT></I>        }
    }

    <I><FONT COLOR="#B22222">// use priority queue in which top element has the &quot;smallest&quot; priority
</FONT></I>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; Q;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dist(N, INF), dad(N, -1);
    Q.push(make_pair(0, s));
    dist[s] = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (!Q.empty()) {
        PII p = Q.top();
        Q.pop();
        <B><FONT COLOR="#228B22">int</FONT></B> here = p.second;
        <B><FONT COLOR="#A020F0">if</FONT></B> (here == t) <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist[here] != p.first) <B><FONT COLOR="#A020F0">continue</FONT></B>;

        <B><FONT COLOR="#A020F0">for</FONT></B> (vector&lt;PII&gt;::iterator it = edges[here].begin(); it != edges[here].end(); it++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (dist[here] + it-&gt;first &lt; dist[it-&gt;second]) {
                dist[it-&gt;second] = dist[here] + it-&gt;first;
                dad[it-&gt;second] = here;
                Q.push(make_pair(dist[it-&gt;second], it-&gt;second));
            }
        }
    }

    printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>, dist[t]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist[t] &lt; INF)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = t; i != -1; i = dad[i])
            printf(<B><FONT COLOR="#BC8F8F">&quot;%d%c&quot;</FONT></B>, i, (i == s ? <B><FONT COLOR="#BC8F8F">'\n'</FONT></B> : <B><FONT COLOR="#BC8F8F">' '</FONT></B>));
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/*
Sample input:
5 0 4
2 1 2 3 1
2 2 4 4 5
3 1 4 3 3 4 1
2 0 1 2 3
2 1 5 2 1

Expected:
5
4 2 3 0
*/</FONT></I></PRE>
<HR>
<A NAME="file34">
<H1>code/SCC.cc 34/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file33">prev</A>][<A HREF="#file35">next</A>]
<PRE>
vi val, comp, z, cont;
<B><FONT COLOR="#228B22">int</FONT></B> Time, ncomps;
<I><FONT COLOR="#B22222">// A function that will be called with the indicies of all elements
</FONT></I><I><FONT COLOR="#B22222">// in each component as the parameter once per component after running scc.
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">f</FONT></B>(vi node_inds) {};
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j, vector&lt;vi&gt;&amp; g) {
    <B><FONT COLOR="#228B22">int</FONT></B> low = val[j] = ++Time, x; z.push_back(j);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : g[j]) <B><FONT COLOR="#A020F0">if</FONT></B> (comp[e] &lt; 0)
            low = min(low, val[e] ?: dfs(e,g));

    <B><FONT COLOR="#A020F0">if</FONT></B> (low == val[j]) {
        <B><FONT COLOR="#A020F0">do</FONT></B> {
            x = z.back(); z.pop_back();
            comp[x] = ncomps;
            cont.push_back(x);
        } <B><FONT COLOR="#A020F0">while</FONT></B> (x != j);
        f(cont); cont.clear();
        ncomps++;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> val[j] = low;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">scc</FONT></B>(vector&lt;vi&gt;&amp; g) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = g.size();
    val.assign(n, 0); comp.assign(n, -1);
    Time = ncomps = 0;
    rep(i,0,n) <B><FONT COLOR="#A020F0">if</FONT></B> (comp[i] &lt; 0) dfs(i, g);
}
</PRE>
<HR>
<A NAME="file35">
<H1>code/EulerianPath.cc 35/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file34">prev</A>][<A HREF="#file36">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> Edge;
<B><FONT COLOR="#228B22">typedef</FONT></B> list&lt;Edge&gt;::iterator iter;

<B><FONT COLOR="#228B22">struct</FONT></B> Edge {
    <B><FONT COLOR="#228B22">int</FONT></B> next_vertex;
    iter reverse_edge;
    Edge(<B><FONT COLOR="#228B22">int</FONT></B> next_vertex)
            : next_vertex(next_vertex) {}
};

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> max_vertices =;
<B><FONT COLOR="#228B22">int</FONT></B> num_vertices;
list &lt;Edge&gt; adj[max_vertices];        <I><FONT COLOR="#B22222">// adjacency list
</FONT></I>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; path;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">find_path</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> v) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (adj[v].size() &gt; 0) {
        <B><FONT COLOR="#228B22">int</FONT></B> vn = adj[v].front().next_vertex;
        adj[vn].erase(adj[v].front().reverse_edge);
        adj[v].pop_front();
        find_path(vn);
    }
    path.push_back(v);
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">add_edge</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    adj[a].push_front(Edge(b));
    iter ita = adj[a].begin();
    adj[b].push_front(Edge(a));
    iter itb = adj[b].begin();
    ita-&gt;reverse_edge = itb;
    itb-&gt;reverse_edge = ita;
}
</PRE>
<HR>
<A NAME="file36">
<H1>code/Prim.cc 36/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file35">prev</A>][<A HREF="#file37">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This function runs Prim's algorithm for constructing minimum
</FONT></I><I><FONT COLOR="#B22222">// weight spanning trees.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^2)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   w[i][j] = cost of edge from i to j
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//            NOTE: Make sure that w[i][j] is nonnegative and
</FONT></I><I><FONT COLOR="#B22222">//            symmetric.  Missing edges should be given -1
</FONT></I><I><FONT COLOR="#B22222">//            weight.
</FONT></I><I><FONT COLOR="#B22222">//            
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  edges = list of pair&lt;int,int&gt; in minimum spanning tree
</FONT></I><I><FONT COLOR="#B22222">//            return total weight of tree
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;

T Prim(<B><FONT COLOR="#228B22">const</FONT></B> VVT &amp;w, VPII &amp;edges) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
    VI found(n);
    VI prev(n, -1);
    VT dist(n, 1000000000);
    <B><FONT COLOR="#228B22">int</FONT></B> here = 0;
    dist[here] = 0;

    <B><FONT COLOR="#A020F0">while</FONT></B> (here != -1) {
        found[here] = true;
        <B><FONT COLOR="#228B22">int</FONT></B> best = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (!found[k]) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (w[here][k] != -1 &amp;&amp; dist[k] &gt; w[here][k]) {
                    dist[k] = w[here][k];
                    prev[k] = here;
                }
                <B><FONT COLOR="#A020F0">if</FONT></B> (best == -1 || dist[k] &lt; dist[best]) best = k;
            }
        here = best;
    }

    T tot_weight = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
        <B><FONT COLOR="#A020F0">if</FONT></B> (prev[i] != -1) {
            edges.push_back(make_pair(prev[i], i));
            tot_weight += w[prev[i]][i];
        }
    <B><FONT COLOR="#A020F0">return</FONT></B> tot_weight;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> ww[5][5] = {
            {0,   400, 400, 300, 600},
            {400, 0,   3,   -1,  7},
            {400, 3,   0,   2,   0},
            {300, -1,  2,   0,   5},
            {600, 7,   0,   5,   0}
    };
    VVT w(5, VT(5));
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 5; i++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 5; j++)
            w[i][j] = ww[i][j];


    VPII edges;
    cout &lt;&lt; Prim(w, edges) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 305
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; edges.size(); i++)
        cout &lt;&lt; edges[i].first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; edges[i].second &lt;&lt; endl;
    <I><FONT COLOR="#B22222">//           2 1
</FONT></I>    <I><FONT COLOR="#B22222">//           3 2
</FONT></I>    <I><FONT COLOR="#B22222">//           0 3
</FONT></I>    <I><FONT COLOR="#B22222">//           2 4
</FONT></I>}
</PRE>
<HR>
<A NAME="file37">
<H1>code/LongestIncreasingSubsequence.cc 37/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file36">prev</A>][<A HREF="#file38">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Given a list of numbers of length n, this routine extracts a
</FONT></I><I><FONT COLOR="#B22222">// longest increasing subsequence.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n log n)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT: a vector of integers
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT: a vector containing the longest increasing subsequence
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">STRICTLY_INCREASNG</FONT>

VI <B><FONT COLOR="#0000FF">LongestIncreasingSubsequence</FONT></B>(VI v) {
    VPII best;
    VI dad(v.size(), -1);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); i++) {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">STRICTLY_INCREASNG</FONT>
        PII item = make_pair(v[i], 0);
        <B><FONT COLOR="#5F9EA0">VPII</FONT></B>::iterator it = lower_bound(best.begin(), best.end(), item);
        item.second = i;
#<B><FONT COLOR="#5F9EA0">else
</FONT></B>
        PII item = make_pair(v[i], i);
        <B><FONT COLOR="#5F9EA0">VPII</FONT></B>::iterator it = upper_bound(best.begin(), best.end(), item);
#<B><FONT COLOR="#5F9EA0">endif
</FONT></B>
        <B><FONT COLOR="#A020F0">if</FONT></B> (it == best.end()) {
            dad[i] = (best.size() == 0 ? -1 : best.back().second);
            best.push_back(item);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
            dad[i] = it == best.begin() ? -1 : prev(it)-&gt;second;
            *it = item;
        }
    }

    VI ret;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = best.back().second; i &gt;= 0; i = dad[i])
        ret.push_back(v[i]);
    reverse(ret.begin(), ret.end());
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
</PRE>
<HR>
<A NAME="file38">
<H1>code/LCS.cc 38/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file37">prev</A>][<A HREF="#file39">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/*
Calculates the length of the longest common subsequence of two vectors.
Backtracks to find a single subsequence or all subsequences. Runs in
O(m*n) time except for finding all longest common subsequences, which
may be slow depending on how many there are.
*/</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">backtrack</FONT></B>(VVI &amp;dp, VT &amp;res, VT &amp;A, VT &amp;B, <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!i || !j) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (A[i - 1] == B[j - 1]) {
        res.push_back(A[i - 1]);
        backtrack(dp, res, A, B, i - 1, j - 1);
    }
    <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dp[i][j - 1] &gt;= dp[i - 1][j]) backtrack(dp, res, A, B, i, j - 1);
        <B><FONT COLOR="#A020F0">else</FONT></B> backtrack(dp, res, A, B, i - 1, j);
    }
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">backtrackall</FONT></B>(VVI &amp;dp, set&lt;VT&gt; &amp;res, VT &amp;A, VT &amp;B, <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!i || !j) {
        res.insert(VI());
        <B><FONT COLOR="#A020F0">return</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (A[i - 1] == B[j - 1]) {
        set&lt;VT&gt; tempres;
        backtrackall(dp, tempres, A, B, i - 1, j - 1);
        <B><FONT COLOR="#A020F0">for</FONT></B> (set&lt;VT&gt;::iterator it = tempres.begin(); it != tempres.end(); it++) {
            VT temp = *it;
            temp.push_back(A[i - 1]);
            res.insert(temp);
        }
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dp[i][j - 1] &gt;= dp[i - 1][j]) backtrackall(dp, res, A, B, i, j - 1);
        <B><FONT COLOR="#A020F0">if</FONT></B> (dp[i][j - 1] &lt;= dp[i - 1][j]) backtrackall(dp, res, A, B, i - 1, j);
    }
}
VT <B><FONT COLOR="#0000FF">LCS</FONT></B>(VT &amp;A, VT &amp;B) {
    VVI dp;
    <B><FONT COLOR="#228B22">int</FONT></B> n = A.size(), m = B.size();
    dp.resize(n + 1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= n; i++) dp[i].resize(m + 1, 0);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= m; j++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (A[i - 1] == B[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            <B><FONT COLOR="#A020F0">else</FONT></B> dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }

    VT res;
    backtrack(dp, res, A, B, n, m);
    reverse(res.begin(), res.end());
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}
set&lt;VT&gt; LCSall(VT &amp;A, VT &amp;B) {
    VVI dp;
    <B><FONT COLOR="#228B22">int</FONT></B> n = A.size(), m = B.size();
    dp.resize(n + 1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= n; i++) dp[i].resize(m + 1, 0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= m; j++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (A[i - 1] == B[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            <B><FONT COLOR="#A020F0">else</FONT></B> dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    set&lt;VT&gt; res;
    backtrackall(dp, res, A, B, n, m);
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> a[] = {0, 5, 5, 2, 1, 4, 2, 3}, b[] = {5, 2, 4, 3, 2, 1, 2, 1, 3};
    VI A = VI(a, a + 8), B = VI(b, b + 9);
    VI C = LCS(A, B);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; C.size(); i++) cout &lt;&lt; C[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    cout &lt;&lt; endl &lt;&lt; endl;

    set&lt;VI&gt; D = LCSall(A, B);
    <B><FONT COLOR="#A020F0">for</FONT></B> (set&lt;VI&gt;::iterator it = D.begin(); it != D.end(); it++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (*it).size(); i++) cout &lt;&lt; (*it)[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        cout &lt;&lt; endl;
    }
}
</PRE>
<HR>
<A NAME="file39">
<H1>code/KMP.cc 39/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file38">prev</A>][<A HREF="#file40">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/*
Finds all occurrences of the pattern string p within the
text string t. Running time is O(n + m), where n and m
are the lengths of p and t, respecitvely.
*/</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">buildPi</FONT></B>(string &amp;p, VI &amp;pi) {
    pi = VI(p.length());
    <B><FONT COLOR="#228B22">int</FONT></B> k = -2;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.length(); i++) {
        <B><FONT COLOR="#A020F0">while</FONT></B> (k &gt;= -1 &amp;&amp; p[k + 1] != p[i])
            k = (k == -1) ? -2 : pi[k];
        pi[i] = ++k;
    }
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">KMP</FONT></B>(string &amp;t, string &amp;p) {
    VI pi;
    buildPi(p, pi);
    <B><FONT COLOR="#228B22">int</FONT></B> k = -1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; t.length(); i++) {
        <B><FONT COLOR="#A020F0">while</FONT></B> (k &gt;= -1 &amp;&amp; p[k + 1] != t[i])
            k = (k == -1) ? -2 : pi[k];
        k++;
        <B><FONT COLOR="#A020F0">if</FONT></B> (k == p.length() - 1) {
            <I><FONT COLOR="#B22222">// p matches t[i-m+1, ..., i]
</FONT></I>            cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;matched at index &quot;</FONT></B> &lt;&lt; i - k &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B>;
            cout &lt;&lt; t.substr(i - k, p.length()) &lt;&lt; endl;
            k = (k == -1) ? -2 : pi[k];
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    string a = <B><FONT COLOR="#BC8F8F">&quot;AABAACAADAABAABA&quot;</FONT></B>, b = <B><FONT COLOR="#BC8F8F">&quot;AABA&quot;</FONT></B>;
    KMP(a, b); <I><FONT COLOR="#B22222">// expected matches at: 0, 9, 12
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file40">
<H1>code/Zfunc.cpp 40/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file39">prev</A>][<A HREF="#file41">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Author: chilli
 * License: CC0
 * Description: z[x] computes the length of the longest common prefix of s[i:] and s, except z[0] = 0. (abacaba -&gt; 0010301)
 * Time: O(n)
 * Status: stress-tested
 */</FONT></I>
#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">once</FONT>

vi <B><FONT COLOR="#0000FF">Z</FONT></B>(string S) {
    vi z(sz(S));
    <B><FONT COLOR="#228B22">int</FONT></B> l = -1, r = -1;
    rep(i,1,sz(S)) {
        z[i] = i &gt;= r ? 0 : min(r - i, z[i - l]);
        <B><FONT COLOR="#A020F0">while</FONT></B> (i + z[i] &lt; sz(S) &amp;&amp; S[i + z[i]] == S[z[i]])
            z[i]++;
        <B><FONT COLOR="#A020F0">if</FONT></B> (i + z[i] &gt; r)
            l = i, r = i + z[i];
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> z;
}</PRE>
<HR>
<A NAME="file41">
<H1>code/Manacher.cpp 41/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file40">prev</A>][<A HREF="#file42">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Author: User adamant on CodeForces
 * Source: http://codeforces.com/blog/entry/12143
 * Description: For each position in a string, computes p[0][i] = half length of
 *  longest even palindrome around pos i, p[1][i] = longest odd (half rounded down).
 * Time: O(N)
 * Status: Stress-tested
 */</FONT></I>
array&lt;vi, 2&gt; manacher(<B><FONT COLOR="#228B22">const</FONT></B> string&amp; s) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = sz(s);
    array&lt;vi,2&gt; p = {vi(n+1), vi(n)};
    rep(z,0,2) <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i=0,l=0,r=0; i &lt; n; i++) {
            <B><FONT COLOR="#228B22">int</FONT></B> t = r-i+!z;
            <B><FONT COLOR="#A020F0">if</FONT></B> (i&lt;r) p[z][i] = min(t, p[z][l+t]);
            <B><FONT COLOR="#228B22">int</FONT></B> L = i-p[z][i], R = i+p[z][i]-!z;
            <B><FONT COLOR="#A020F0">while</FONT></B> (L&gt;=1 &amp;&amp; R+1&lt;n &amp;&amp; s[L-1] == s[R+1])
                p[z][i]++, L--, R++;
            <B><FONT COLOR="#A020F0">if</FONT></B> (R&gt;r) l=L, r=R;
        }
    <B><FONT COLOR="#A020F0">return</FONT></B> p;
}</PRE>
<HR>
<A NAME="file42">
<H1>code/Primes.cc 42/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file41">prev</A>][<A HREF="#file43">next</A>]
<PRE>
# <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">EPS</FONT> 1e-7
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsPrime</FONT></B>(LL x) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (x &lt;= 1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B> (x &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(x % 2) || !(x % 3)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    LL s = (LL) (sqrt((<B><FONT COLOR="#228B22">double</FONT></B>) (x)) + EPS);
    <B><FONT COLOR="#A020F0">for</FONT></B> (LL i = 5; i &lt;= s; i += 6) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!(x % i) || !(x % (i + 2))) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">// Factor every number up until n in O(n) time.
</FONT></I><I><FONT COLOR="#B22222">// minFact[i] = the minimum factor of i higher than 1. minFact[0] = minFact[1] = 0
</FONT></I><I><FONT COLOR="#B22222">// primes[i] = the ith prime.
</FONT></I>vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; factorAll(<B><FONT COLOR="#228B22">int</FONT></B> n) {
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; primes(0);
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; minFact(n + 1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (minFact[i] == 0) {
            primes.push_back(i);
            minFact[i] = i;
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; primes.size() &amp;&amp; primes[j] &lt;= minFact[i] &amp;&amp; i * primes[j] &lt;= n; ++j) {
            minFact[i * primes[j]] = primes[j];
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> primes;
}
<I><FONT COLOR="#B22222">// Primes close to 1e9: 999'999'937, 1'000'000'007, 1'000'000'009
</FONT></I></PRE>
<HR>
<A NAME="file43">
<H1>code/BinarySearch.cpp 43/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file42">prev</A>][<A HREF="#file44">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This code is guaranteed to work in the min number of ops
</FONT></I><I><FONT COLOR="#B22222">// for any MAX that fits in an ll.
</FONT></I>ll MAX = 1LL &lt;&lt; 63;
<I><FONT COLOR="#B22222">// Binary search integers in the range [0, MAX)
</FONT></I><I><FONT COLOR="#B22222">// for the last element satisfying condition.
</FONT></I><B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1LL &lt;&lt; (<B><FONT COLOR="#228B22">int</FONT></B>) (log2(MAX)); j != 0; j &gt;&gt;= 1) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (condition(lo + j)) {
        lo += j;
    }
}
<I><FONT COLOR="#B22222">// Binary search integers in the range (1, MAX]
</FONT></I><I><FONT COLOR="#B22222">// for the first element satisfying condition.
</FONT></I>ll hi = 1LL &lt;&lt; (<B><FONT COLOR="#228B22">int</FONT></B>) (log2(MAX) + 1);
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1LL &lt;&lt; (<B><FONT COLOR="#228B22">int</FONT></B>) (log2(MAX)); j != 0; j &gt;&gt;= 1) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (condition(0, hi - j)) {
        hi -= j;
    }
}
</PRE>
<HR>
<A NAME="file44">
<H1>code/LatLong.cc 44/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file43">prev</A>][<A HREF="#file45">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/*
Converts from rectangular coordinates to latitude/longitude and vice
versa. Uses degrees (not radians).
*/</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> ll {
    <B><FONT COLOR="#228B22">double</FONT></B> r, lat, lon;
};
<B><FONT COLOR="#228B22">struct</FONT></B> rect {
    <B><FONT COLOR="#228B22">double</FONT></B> x, y, z;
};
ll <B><FONT COLOR="#0000FF">convert</FONT></B>(rect &amp;P) {
    ll Q;
    Q.r = sqrt(P.x * P.x + P.y * P.y + P.z * P.z);
    Q.lat = 180 / M_PI * asin(P.z / Q.r);
    Q.lon = 180 / M_PI * acos(P.x / sqrt(P.x * P.x + P.y * P.y));

    <B><FONT COLOR="#A020F0">return</FONT></B> Q;
}
rect <B><FONT COLOR="#0000FF">convert</FONT></B>(ll &amp;Q) {
    rect P;
    P.x = Q.r * cos(Q.lon * M_PI / 180) * cos(Q.lat * M_PI / 180);
    P.y = Q.r * sin(Q.lon * M_PI / 180) * cos(Q.lat * M_PI / 180);
    P.z = Q.r * sin(Q.lat * M_PI / 180);

    <B><FONT COLOR="#A020F0">return</FONT></B> P;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    rect A;
    ll B;

    A.x = -1.0;
    A.y = 2.0;
    A.z = -3.0;

    B = convert(A);
    cout &lt;&lt; B.r &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; B.lat &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; B.lon &lt;&lt; endl;

    A = convert(B);
    cout &lt;&lt; A.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; A.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; A.z &lt;&lt; endl;
}
</PRE>
<HR>
<A NAME="file45">
<H1>code/CSP.cc 45/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file44">prev</A>][next]
<PRE>
<I><FONT COLOR="#B22222">// Constraint satisfaction problems
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;set&gt;</FONT></B>
using namespace std;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">DONE</FONT>   -1
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">FAILED</FONT> -2

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VVI&gt; VVVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> set&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; SI;
<I><FONT COLOR="#B22222">// Lists of assigned/unassigned variables.
</FONT></I>VI assigned_vars;
SI unassigned_vars;
<I><FONT COLOR="#B22222">// For each variable, a list of reductions (each of which a list of eliminated
</FONT></I><I><FONT COLOR="#B22222">// variables)
</FONT></I>VVVI reductions;
<I><FONT COLOR="#B22222">// For each variable, a list of the variables whose domains it reduced in
</FONT></I><I><FONT COLOR="#B22222">// forward-checking.
</FONT></I>VVI forward_mods;
<I><FONT COLOR="#B22222">// need to implement ----------------------------
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Value</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">SetValue</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var, <B><FONT COLOR="#228B22">int</FONT></B> value);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">ClearValue</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var);
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">DomainSize</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">ResetDomain</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">AddValue</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var, <B><FONT COLOR="#228B22">int</FONT></B> value);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">RemoveValue</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var, <B><FONT COLOR="#228B22">int</FONT></B> value);
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">NextVar</FONT></B>() {
    <B><FONT COLOR="#A020F0">if</FONT></B> (unassigned_vars.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> DONE;

    <I><FONT COLOR="#B22222">// could also do most constrained...
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> var = *unassigned_vars.begin();
    <B><FONT COLOR="#A020F0">return</FONT></B> var;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Initialize</FONT></B>() {
    <I><FONT COLOR="#B22222">// setup here
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> NextVar();
}
<I><FONT COLOR="#B22222">// ------------------------- end -- need to implement
</FONT></I>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">UpdateCurrentDomain</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var) {
    ResetDomain(var);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; reductions[var].size(); i++) {
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;red = reductions[var][i];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; red.size(); j++) {
            RemoveValue(var, red[j]);
        }
    }
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">UndoReductions</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; forward_mods[var].size(); i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> other_var = forward_mods[var][i];
        VI &amp;red = reductions[other_var].back();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; red.size(); j++) {
            AddValue(other_var, red[j]);
        }
        reductions[other_var].pop_back();
    }
    forward_mods[var].clear();
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">ForwardCheck</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> var, <B><FONT COLOR="#228B22">int</FONT></B> other_var) {
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; red;

    foreach
    value
    in current_domain(other_var) {
        SetValue(other_var, value);
        <B><FONT COLOR="#A020F0">if</FONT></B> (!Consistent(var, other_var)) {
            red.push_back(value);
            RemoveValue(other_var, value);
        }
        ClearValue(other_var);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!red.empty()) {
        reductions[other_var].push_back(red);
        forward_mods[var].push_back(other_var);
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> DomainSize(other_var) != 0;
}
pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; Unlabel(<B><FONT COLOR="#228B22">int</FONT></B> var) {
    assigned_vars.pop_back();
    unassigned_vars.insert(var);

    UndoReductions(var);
    UpdateCurrentDomain(var);

    <B><FONT COLOR="#A020F0">if</FONT></B> (assigned_vars.empty()) <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(FAILED, true);

    <B><FONT COLOR="#228B22">int</FONT></B> prev_var = assigned_vars.back();
    RemoveValue(prev_var, Value(prev_var));
    ClearValue(prev_var);
    <B><FONT COLOR="#A020F0">if</FONT></B> (DomainSize(prev_var) == 0) {
        <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(prev_var, false);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(prev_var, true);
    }
}
pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; Label(<B><FONT COLOR="#228B22">int</FONT></B> var) {
    unassigned_vars.erase(var);
    assigned_vars.push_back(var);

    <B><FONT COLOR="#228B22">bool</FONT></B> consistent;
    foreach
    value
    in current_domain(var) {
        SetValue(var, value);
        consistent = true;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; unassigned_vars.size(); j++) {
            <B><FONT COLOR="#228B22">int</FONT></B> other_var = unassigned_vars[j];
            <B><FONT COLOR="#A020F0">if</FONT></B> (!ForwardCheck(var, other_var)) {
                RemoveValue(var, value);
                consistent = false;
                UndoReductions(var);
                ClearValue(var);
                <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (consistent) <B><FONT COLOR="#A020F0">return</FONT></B> (NextVar(), true);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(var, false);
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">BacktrackSearch</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> num_var) {
    <I><FONT COLOR="#B22222">// (next variable to mess with, whether current state is consistent)
</FONT></I>    pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">bool</FONT></B>&gt; var_consistent = make_pair(Initialize(), true);
    <B><FONT COLOR="#A020F0">while</FONT></B> (true) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (var_consistent.second) var_consistent = Label(var_consistent.first);
        <B><FONT COLOR="#A020F0">else</FONT></B> var_consistent = Unlabel(var_consistent.first);

        <B><FONT COLOR="#A020F0">if</FONT></B> (var_consistent.first == DONE) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">// solution found
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (var_consistent.first == FAILED) <B><FONT COLOR="#A020F0">return</FONT></B>; <I><FONT COLOR="#B22222">// no solution
</FONT></I>    }
}
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>
</HTML>
